---
title: "Preliminary Analyses of Survival, Recruitment, Resight, and Emigration"
author: "Brian W. Rolek"
date: "April 19, 2021"
output:
  html_document:
    df_print: paged
    toc: yes
  github_document:
    toc: yes
---

```{r setup, include=FALSE, error=TRUE}
knitr::opts_chunk$set(echo = TRUE)
```

#S1 Supplemental materials   
for:  
B. W. Rolek, B. Pauli, A. Macias-Duarte, B. Mutch, P. Juergens, T. Anderson, C. Parish, J. Johnson, B. Millsap, C. J. W. McClure. 2021. LONG-TERM DEMOGRAPHY OF A REINTRODUCED AND ISOLATED POPULATION OF ENDANGERED FALCONS

# 1. Model Formulation

## 1.1 Introduction
This Rmarkdown document describes preliminary analyses using a Cormack-Jolly-Seber model with a state-space formulation (Gimenez et al. 2007, Royle et al. 2008). These analyses assess the importance of covariates for later inclusion in the integrated population model (IPM), and assess the importance of emigration for inclusion in the IPM. 

## 1.2 Observation Matrix  
First, we specified the observation matrix ($PO$) that relates observed states (columns) to real states (rows) of Northern Aplomado Falcons.  
Observed states (1--5, columns left to right):  
1.  Seen first-year  
2.  Seen nonbreeder  
3.  Seen breeder  
4.  Seen dead  
5.  Not seen  

Real states (1--7, rows top to bottom):  
1.  First-year  
2.  Nonbreeder  
3.  Breeder  
4.  Recovered recently dead   
5.  Dead not recovered  
6.  Emigrated and alive  
7.  Emigrated and dead  

where superscripts with capital letters are used as labels for life cycle states: first-year ($O$), nonbreeder ($A$), and breeder ($B$). Observations are related to true states using transition and resight probabilities ($p$) for nonbreeder ($p^A$) and breeders ($p^B$):
$$PO=
\begin{bmatrix} 
1 & 0 & 0 & 0 & 0\\
0 & p^A & 0 & 0 & 1-p^A\\
0 & 0 & p^B & 0 & 1-p^B\\
0 & 0 & 0 & 1 & 0\\
0 & 0 & 0 & 0 & 1\\
0 & 0 & 0 & 0 & 1\\
0 & 0 & 0 & 0 & 1\\
\end{bmatrix}
$$
We could not estimate resight probabilities of first-year birds because they can only be observed once and cannot be resighted. Therefore, we assume perfect resight probability (1.0 at row 1 and column 1) because most of these were released captive bred birds or were birds observed during productivity surveys. 

## 1.3 State Transition Matrix  
Next, we specified the state transition matrix ($\Omega$) that governs dynamics between true states over time. Rows of the matrix represent true states during time step ($t$), and columns represent true states during the following time step ($t+1$). Each row and column number correspond to true states listed above. For example, row 1 corresponds with first-year at time t and column 1 corresponds with first-year at time t+1.
$$ \Omega=
\begin{bmatrix} 
0 & \phi^F(1-\psi^F)(1-\delta)  & \phi^F\psi^F(1-\delta) & (1-\phi^F)r(1-\delta) & (1-\phi^F)(1-r)(1-\delta) & \phi^F\delta & (1-\phi^F)(1-r)\delta\\ 
0 & \phi^A(1-\psi^A)(1-\delta)  & \phi^A\psi^A(1-\delta) & (1-\phi^A)r(1-\delta) & (1-\phi^A)(1-r)(1-\delta) & \phi^A\delta & (1-\phi^A)(1-r)\delta\\ 
0 & \phi^B(1-\psi^B)(1-\delta)  & \phi^B\psi^B(1-\delta) & (1-\phi^B)r(1-\delta) & (1-\phi^B)(1-r)(1-\delta) & \phi^B\delta & (1-\phi^B)(1-r)\delta\\ 
0 & 0 & 0 & 0 & 1 & 0 & 0\\
0 & 0 & 0 & 0 & 1 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 1 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 1\\
\end{bmatrix}
$$

## 1.4 Global CJS Survival Model Constraints  
We implemented the global survival model in Just Another Gibbs Sampler (JAGS). The "global survival model" includes all covariates considered here. Probabilities of survival ($\phi$), recruitment ($\psi$), and resight ($p$) are contrained to vary by sex ($s$, male or female), hacked ($h$, wild-born or captive bred). Each life stage (first-year, nonbreeder, breeder) and group (sex, hacked, effort) has a unique variance parameter over time. We used the same constraints for first-year, nonbreeder, and breeder birds. Superscripts with greek symbols are used to label parameters. 
$$logit(\phi_{i,t})=\mu_{s,h}^{\phi} + \epsilon_{s,h,t}^{\phi}$$
$$\epsilon_{s,h,t}^{\phi}=normal(0,\tau=1/\sigma_{s,h}^{\phi,2})$$ 
$$logit(\psi_{i,t})=\mu_{s,h}^{\psi} + \epsilon_{s,h,t}^{\psi}$$

$$\epsilon_{s,h,t}^{\psi}=normal(0,\tau=1/\sigma_{s,h}^{\psi,2})$$ 
Furthermore, probability of resight varied by field effort ($e$) for nonbreeders and breeders. 
$$logit(p_{i,t})=\mu_{s,h,e}^{p} + \epsilon_{s,h,e,t}^{p}$$
$$\epsilon_{s,h,e,t}^{p}=normal(0,\tau=1/\sigma_{s,h,e}^{p,2})$$ 
Probabilities of emigration ($\delta$) and dead recovery ($r$) are contrained to constant values over time to aid with convergence and for computational efficiency. 
$$logit(\delta_{i,t})=\mu^{\delta}$$
Including emigration within this model allowed us to estimate _true_ survival rather than _apparent_ survival, because apparent survival is confounded with emigration in some CJS models. 

# 2. Implementation of the Global CJS Survival Model

## 2.1 JAGS and R Code for Implementing the Global CJS Survival Model
```{r globalmod, message=FALSE, eval=FALSE}
# Must have JAGS installed to run this code
library (jagsUI)
load(".//data//final-data.Rdata")
m<- c("surv7-jags-global") # name for files
modfl <- paste( m, ".txt", sep="")

sink(modfl)
cat("
    model{
    ####################################################
    ####################################################
    # Mark-resight-recovery data
    #   Observations (O) = y  
    #     1 seen first year (age 0)
    #     2 seen nonbreeder
    #     3 seen breeder
    #     4 recovered dead
    #     5 not seen
    #   States (S)
    #     1 alive first year
    #     2 alive nonbreeder
    #     3 alive breeder
    #     4 dead
    #     5 dead not recovered
    #     6 emigrated alive
    #     7 emigrated dead
    #   Groups
    #     1 wild born
    #     2 hacked
    #   Sex
    #     1 female
    #     2 male
    #   Effort
    #     1 low
    #     2 high
    ###################################################
    # PARAMETERS
    #   sO: survival probability first year 
    #       (sO as in the letter O rather than zero so jags can parse)
    #   sA: survival probability nonbreeders
    #   sB: survival probability breeders
    #   psiOB: recruitment probability from first-year to breeder
    #   psiAB: recruitment probability from nonbreeders to breeder
    #   psiBA: recruitment probability from breeder to nonbreeders 
    #   pO: resight probability first-year
    #   pA: resight probability nonbreeders
    #   pB: resight probability breeder
    #   em: probability of emigration
    #   r: probability of dead recovery
    ###################################################
    # Priors and constraints
    ###################################################
    l.mu.em <- logit(mu.em)
    mu.em ~ dunif(0,1)
    r ~ dunif(0, 1)

    for (h in 1:2){
    for (s in 1:2){
    for (t in 1:(n.yr-1)){
    logit(eta.OSalpha[s,h,t]) <- OSalpha[s,h] + eps.OS.s[s,h,t]
    logit(eta.ASalpha[s,h,t]) <- ASalpha[s,h] + eps.AS.s[s,h,t]
    logit(eta.BSalpha[s,h,t]) <- BSalpha[s,h] + eps.BS.s[s,h,t]
    logit(eta.ABRalpha[s,h,t]) <- ABRalpha[s,h] + eps.ABR.psi[s,h,t]    
    logit(eta.OBRalpha[s,h,t]) <- OBRalpha[s,h] + eps.OBR.psi[s,h,t]    
    logit(eta.BARalpha[s,h,t]) <- BARalpha[s,h] + eps.BAR.psi[s,h,t]
    logit(eta.pA[s,h,t]) <- mu.pA[s,h,effort[t]] + eps.pA[s,h,t]
    logit(eta.pB[s,h,t]) <- mu.pB[s,h,effort[t]] + eps.pB[s,h,t]
    
    eps.BS.s[s,h,t] ~ dnorm(0, 1/(sigma.BS.s[s,h]*sigma.BS.s[s,h])) 
    eps.AS.s[s,h,t] ~ dnorm(0, 1/(sigma.AS.s[s,h]*sigma.AS.s[s,h]))
    eps.OS.s[s,h,t] ~ dnorm(0, 1/(sigma.OS.s[s,h]*sigma.OS.s[s,h]))
    eps.OBR.psi[s,h,t] ~ dnorm(0, 1/(sigma.OBR.psi[s,h]*sigma.OBR.psi[s,h]))
    eps.ABR.psi[s,h,t] ~ dnorm(0, 1/(sigma.ABR.psi[s,h]*sigma.ABR.psi[s,h]))
    eps.BAR.psi[s,h,t] ~ dnorm(0, 1/(sigma.BAR.psi[s,h]*sigma.BAR.psi[s,h]))
    eps.pA[s,h,t] ~ dnorm(0, 1/(sigma.pA[s,h]*sigma.pA[s,h]))     
    eps.pB[s,h,t] ~ dnorm(0, 1/(sigma.pB[s,h]*sigma.pB[s,h]))
    } } } #s sex #h hacked #t time

    for (h in 1:2){
    for (s in 1:2){

    for (k in 1:2){
    mu.pB[s,h,k]<- logit(mu.pB1[s,h,k])
    mu.pB1[s,h,k] ~ dunif(0, 1)
    mu.pA[s,h,k] <- logit(mu.pA1[s,h,k])
    mu.pA1[s,h,k] ~ dunif(0,1)
    } #k effort

    OSalpha[s,h] <- logit(OSalpha1[s,h]) 
    OSalpha1[s,h] ~ dunif(0, 1)
    ASalpha[s,h] <- logit(ASalpha1[s,h])
    ASalpha1[s,h] ~ dunif(0, 1)
    BSalpha[s,h] <- logit(BSalpha1[s,h]) 
    BSalpha1[s,h] ~ dunif(0, 1)
    ABRalpha[s,h] <- logit(ABRalpha1[s,h])
    ABRalpha1[s,h] ~ dunif(0, 1)
    BARalpha[s,h] <- logit(BARalpha1[s,h])
    BARalpha1[s,h] ~ dunif(0, 1)
    OBRalpha[s,h] <- logit(OBRalpha1[s,h]) 
    OBRalpha1[s,h] ~ dunif(0, 1)

    sigma.OS.s[s,h] ~ dunif(0,10)    
    sigma.AS.s[s,h] ~ dunif(0,10)
    sigma.BS.s[s,h] ~ dunif(0,10)
    sigma.OBR.psi[s,h] ~ dunif(0,10)
    sigma.ABR.psi[s,h] ~ dunif(0,10)
    sigma.BAR.psi[s,h] ~ dunif(0,10)
    sigma.pB[s,h] ~ dunif(0,10)
    sigma.pA[s,h] ~ dunif(0,10)
    }} # s h

    for (t in 1:(n.yr-1)){
    logit(em[t]) <-  l.mu.em 
    } #t time

    ################################
    # Likelihood for survival
    ################################
    for (i in 1:nind){
    for (t in 1:(n.yr-1)){
    #Survival
    sO[i,t] <- eta.OSalpha[sex[i],hacked[i], t] # first year
    sA[i,t] <- eta.ASalpha[sex[i],hacked[i], t] # nonbreeder
    sB[i,t] <- eta.BSalpha[sex[i],hacked[i], t] # breeder
    #Recruitment
    psiOB[i,t] <- eta.OBRalpha[sex[i],hacked[i], t] # first year to breeder
    psiAB[i,t] <- eta.ABRalpha[sex[i],hacked[i], t] # nonbreeder to breeder
    psiBA[i,t] <- eta.BARalpha[sex[i],hacked[i], t] # breeder to nonbreeder
    #Re-encounter
    pA[i,t] <- eta.pA[sex[i],hacked[i], t] # resight of nonbreeders
    pB[i,t] <- eta.pB[sex[i],hacked[i], t]  # resight of breeders
    }#t
    }#i
    
    # Define state-transition and observation matrices
    for (i in 1:nind){  
    # Define probabilities of state S(t+1) given S(t)
    for (t in first[i]:(n.yr-1)){
    ps[1,i,t,1] <- 0
    ps[1,i,t,2] <- sO[i,t] * (1-psiOB[i,t]) * (1-em[t])
    ps[1,i,t,3] <- sO[i,t] * psiOB[i,t] * (1-em[t])
    ps[1,i,t,4] <- (1-sO[i,t]) * r * (1-em[t])
    ps[1,i,t,5] <- (1-sO[i,t]) * (1-r) * (1-em[t])
    ps[1,i,t,6] <- sO[i,t] * em[t]
    ps[1,i,t,7] <- (1-sO[i,t]) * (1-r) * em[t]
    
    ps[2,i,t,1] <- 0
    ps[2,i,t,2] <- sA[i,t] * (1-psiAB[i,t]) * (1-em[t])
    ps[2,i,t,3] <- sA[i,t] * psiAB[i,t] * (1-em[t])
    ps[2,i,t,4] <- (1-sA[i,t]) * r * (1-em[t])
    ps[2,i,t,5] <- (1-sA[i,t]) * (1-r) * (1-em[t])
    ps[2,i,t,6] <- sA[i,t] * em[t]
    ps[2,i,t,7] <- (1-sA[i,t]) * (1-r) * em[t]
    
    ps[3,i,t,1] <- 0
    ps[3,i,t,2] <- sB[i,t] * psiBA[i,t] * (1-em[t])
    ps[3,i,t,3] <- sB[i,t] * (1-psiBA[i,t]) * (1-em[t])
    ps[3,i,t,4] <- (1-sB[i,t]) * r * (1-em[t])
    ps[3,i,t,5] <- (1-sB[i,t]) * (1-r) * (1-em[t])
    ps[3,i,t,6] <- sB[i,t] * em[t]
    ps[3,i,t,7] <- (1-sB[i,t]) * (1-r) * em[t]
    
    ps[4,i,t,1] <- 0
    ps[4,i,t,2] <- 0
    ps[4,i,t,3] <- 0
    ps[4,i,t,4] <- 0
    ps[4,i,t,5] <- 1
    ps[4,i,t,6] <- 0
    ps[4,i,t,7] <- 0
    
    ps[5,i,t,1] <- 0
    ps[5,i,t,2] <- 0
    ps[5,i,t,3] <- 0
    ps[5,i,t,4] <- 0
    ps[5,i,t,5] <- 1
    ps[5,i,t,6] <- 0
    ps[5,i,t,7] <- 0
    
    ps[6,i,t,1] <- 0
    ps[6,i,t,2] <- 0
    ps[6,i,t,3] <- 0
    ps[6,i,t,4] <- 0
    ps[6,i,t,5] <- 0
    ps[6,i,t,6] <- 1
    ps[6,i,t,7] <- 0
    
    ps[7,i,t,1] <- 0
    ps[7,i,t,2] <- 0
    ps[7,i,t,3] <- 0
    ps[7,i,t,4] <- 0
    ps[7,i,t,5] <- 0
    ps[7,i,t,6] <- 0
    ps[7,i,t,7] <- 1
    
    # Define probabilities of O(t) given S(t)
    po[1,i,t,1] <- 1 
    po[1,i,t,2] <- 0
    po[1,i,t,3] <- 0
    po[1,i,t,4] <- 0
    po[1,i,t,5] <- 0
    
    po[2,i,t,1] <- 0
    po[2,i,t,2] <- pA[i,t]
    po[2,i,t,3] <- 0
    po[2,i,t,4] <- 0
    po[2,i,t,5] <- 1-pA[i,t]
    
    po[3,i,t,1] <- 0
    po[3,i,t,2] <- 0
    po[3,i,t,3] <- pB[i,t]
    po[3,i,t,4] <- 0
    po[3,i,t,5] <- 1-pB[i,t]
    
    po[4,i,t,1] <- 0
    po[4,i,t,2] <- 0
    po[4,i,t,3] <- 0
    po[4,i,t,4] <- 1
    po[4,i,t,5] <- 0
    
    po[5,i,t,1] <- 0
    po[5,i,t,2] <- 0
    po[5,i,t,3] <- 0
    po[5,i,t,4] <- 0
    po[5,i,t,5] <- 1
    
    po[6,i,t,1] <- 0
    po[6,i,t,2] <- 0
    po[6,i,t,3] <- 0
    po[6,i,t,4] <- 0
    po[6,i,t,5] <- 1
    
    po[7,i,t,1] <- 0
    po[7,i,t,2] <- 0
    po[7,i,t,3] <- 0
    po[7,i,t,4] <- 0
    po[7,i,t,5] <- 1
    } #t
    } #i
    
    # Likelihood 
    for (i in 1:nind){
    # Define latent state at first capture
    z[i,first[i]] <- y[i,first[i]]
    for (t in (first[i]+1):n.yr){
    # State process: draw S(t) given S(t-1)
    z[i,t] ~ dcat(ps[z[i,t-1], i, t-1, 1:7])
    # Observation process: draw O(t) given S(t)
    y[i,t] ~ dcat(po[z[i,t], i, t-1, 1:5])
    } #t
    } #i
    } #model
    ",fill = TRUE)
sink()  

# Initial values
get.first <- function(x) min(which(x!=5))
f <- apply(datl$y, 1, get.first)
get.last <- function(x) max(which(x!=5))
l <- apply(datl$y, 1, get.last)
TFmat <- is.na(z.inits) & is.na(datl$z)
for (i in 1:dim(TFmat)[1]){  TFmat[i,1:f[i]] <- FALSE }
z.inits[TFmat] <- sample(size=445, c(2,3), replace=T, prob=c(0.5, 0.5) ) 

inits <- function(){list(z = z.inits)} 

params <- c(
  "r", "l.mu.em", "mu.em", "em",
  "OSalpha", "ASalpha", "BSalpha", "OBRalpha", "ABRalpha", "BARalpha",  "mu.pA", "mu.pB",
  "OSalpha1", "ASalpha1", "BSalpha1","OBRalpha1", "ABRalpha1", "BARalpha1","mu.pA1", "mu.pB1",
  "eps.OS.s", "eps.AS.s", "eps.BS.s", "eps.OBR.psi", "eps.ABR.psi", "eps.BAR.psi", "eps.pA", "eps.pB", 
  "eta.OSalpha", "eta.ASalpha", "eta.BSalpha", "eta.OBRalpha", "eta.ABRalpha", "eta.BARalpha", "eta.pA",  "eta.pB", 
  "sigma.OS.s", "sigma.AS.s", "sigma.BS.s", "sigma.OBR.psi", "sigma.ABR.psi", "sigma.BAR.psi", "sigma.pA", "sigma.pB"  
)

# MCMC settings
# ni <- 200000; nt <- 100; nb <- 100000; nc <- 3; na <- 10000 # actual run # takes about 1 week on a high performance computer
ni <- 10000; nt <- 1; nb <- 5000; nc <- 1; na <- 100 # time-saving run, but inadequate for convergence
out <- jags(datl, inits, params, modfl, n.chains = nc, n.thin = nt, n.burnin = nb, n.adapt=na, n.iter=ni, parallel=T, module=c("glm", "bugs"))

save(file=paste("./", m, ".Rdata", sep=""), list="out")

```

## 2.2 Postprocess Global Model
We postprocess the output from JAGS to compare sex, hacked, and effort estimates for probabilities of survival, recruitment, resight, and estimate emigration.
```{r funcs, message=FALSE}
library (jagsUI)
library (ggplot2)
library (gridExtra)

# Function to compute highest density interval. From Kruschke 2011.
HDIofMCMC = function( sampleVec , credMass=0.95 ) {
  sortedPts = sort( sampleVec )
  ciIdxInc = floor( credMass * length( sortedPts ) )
  nCIs = length( sortedPts ) - ciIdxInc
  ciWidth = rep( 0 , nCIs )
  for ( i in 1:nCIs ) {
    ciWidth[ i ] = sortedPts[ i + ciIdxInc ] - sortedPts[ i ]
  }
  HDImin = sortedPts[ which.min( ciWidth ) ]
  HDImax = sortedPts[ which.min( ciWidth ) + ciIdxInc ]
  HDIlim = c( HDImin , HDImax )
  return( HDIlim )
}

# Function to compute summary stats over posteriors
data_summary <- function(x) {
  m <- median(x)
  ymin <- HDIofMCMC(x, credMass=0.95)[[1]]
  ymax <- HDIofMCMC(x, credMass=0.95)[[2]]
  return(c(y=m,ymin=ymin,ymax=ymax))
}

```

We load the results from the global model to assess which covariates had important effects on parameters. 
```{r ppsurvival, eval=TRUE}
load("C:\\Users\\rolek.brian\\Documents\\Projects\\APLO IPM\\outputs\\surv7-jags-global.Rdata")

O.surv <- O.rec <- A.surv <- A.rec <- B.surv <- B.rec <- array(NA, dim=c(dim(out$sims.list$OSalpha1)[1],3))
A.resight <- B.resight <-array(NA, dim=c(dim(out$sims.list$mu.pA1)[1],3))
##########################
# First-year (O) capital letter o, rather than zero so code works 
#########################
# Survival
# wild - hacked
O.surv[,1]<- (out$sims.list$OSalpha1[,1,1] +         out$sims.list$OSalpha1[,2,1])/2 -
  (out$sims.list$OSalpha1[,1,2] + out$sims.list$OSalpha1[,2,2])/2
# female - male
O.surv[,2]<- (out$sims.list$OSalpha1[,1,1] + out$sims.list$OSalpha1[,1,2])/2 -
  (out$sims.list$OSalpha1[,2,1] + out$sims.list$OSalpha1[,2,2])/2
# Recruitment
# wild - hacked
O.rec[,1]<- (out$sims.list$OBRalpha1[,1,1] + out$sims.list$OBRalpha1[,2,1])/2 -
  (out$sims.list$OBRalpha1[,1,2] + out$sims.list$OBRalpha1[,2,2])/2
# female - male
O.rec[,2]<- (out$sims.list$OBRalpha1[,1,1] + out$sims.list$OBRalpha1[,1,2])/2 -
  (out$sims.list$OBRalpha1[,2,1] + out$sims.list$OBRalpha1[,2,2])/2

##########################
# Adult Nonbreeders (A)
#########################
# Survival
# wild - hacked
A.surv[,1]<- (out$sims.list$ASalpha1[,1,1] + out$sims.list$ASalpha1[,2,1])/2 -
  (out$sims.list$ASalpha1[,1,2] + out$sims.list$ASalpha1[,2,2])/2
# female - male
A.surv[,2]<- (out$sims.list$ASalpha1[,1,1] + out$sims.list$ASalpha1[,1,2])/2 -
  (out$sims.list$ASalpha1[,2,1] + out$sims.list$ASalpha1[,2,2])/2
# Recruitment
# wild - hacked
A.rec[,1]<- (out$sims.list$ABRalpha1[,1,1] + out$sims.list$ABRalpha1[,2,1])/2 -
  (out$sims.list$ABRalpha1[,1,2] + out$sims.list$ABRalpha1[,2,2])/2
# female - male
A.rec[,2]<- (out$sims.list$ABRalpha1[,1,1] + out$sims.list$ABRalpha1[,1,2])/2 -
  (out$sims.list$ABRalpha1[,2,1] + out$sims.list$ABRalpha1[,2,2])/2
# Resight prob
# wild-hacked
A.resight[,1]<- (out$sims.list$mu.pA1[,1,1,1] + out$sims.list$mu.pA1[,1,1,2] + out$sims.list$mu.pA1[,2,1,1] + out$sims.list$mu.pA1[,2,1,2])/4 -
              (out$sims.list$mu.pA1[,1,2,1] + out$sims.list$mu.pA1[,1,2,2]+
                out$sims.list$mu.pA1[,2,2,1] + out$sims.list$mu.pA1[,2,2,2])/4
# female - male
A.resight[,2]<- (out$sims.list$mu.pA1[,1,1,1] + out$sims.list$mu.pA1[,1,1,2]+
                 out$sims.list$mu.pA1[,1,2,1] + out$sims.list$mu.pA1[,1,2,2])/4 -
              (out$sims.list$mu.pA1[,2,1,1] + out$sims.list$mu.pA1[,2,1,2]+
                 out$sims.list$mu.pA1[,2,2,1] + out$sims.list$mu.pA1[,2,2,2])/4

# high effort - low effort
A.resight[,3]<- (out$sims.list$mu.pA1[,1,1,2] + out$sims.list$mu.pA1[,2,1,2]+
                 out$sims.list$mu.pA1[,1,2,2] + out$sims.list$mu.pA1[,2,2,2])/4 -
              (out$sims.list$mu.pA1[,1,1,1] + out$sims.list$mu.pA1[,2,1,1]+
                out$sims.list$mu.pA1[,1,2,1] + out$sims.list$mu.pA1[,2,2,1])/4
##########################
# Adult Breeders (B)
#########################
# Survival
# wild - hacked
B.surv[,1]<- (out$sims.list$BSalpha1[,1,1] + out$sims.list$BSalpha1[,2,1])/2 -
  (out$sims.list$BSalpha1[,1,2] + out$sims.list$BSalpha1[,2,2])/2
# female - male
B.surv[,2]<- (out$sims.list$BSalpha1[,1,1] + out$sims.list$BSalpha1[,1,2])/2 -
  (out$sims.list$BSalpha1[,2,1] + out$sims.list$BSalpha1[,2,2])/2
# Recruitment
# wild - hacked
B.rec[,1]<- (out$sims.list$BARalpha1[,1,1] + out$sims.list$BARalpha1[,2,1])/2 -
  (out$sims.list$BARalpha1[,1,2] + out$sims.list$BARalpha1[,2,2])/2
# female - male
B.rec[,2]<- (out$sims.list$BARalpha1[,1,1] + out$sims.list$BARalpha1[,1,2])/2 -
  (out$sims.list$BARalpha1[,2,1] + out$sims.list$BARalpha1[,2,2])/2
# resight prob  
# wild-hacked
B.resight[,1]<- (out$sims.list$mu.pB1[,1,1,1] + out$sims.list$mu.pB1[,1,1,2] + out$sims.list$mu.pB1[,2,1,1] + out$sims.list$mu.pB1[,2,1,2])/4 -
              (out$sims.list$mu.pB1[,1,2,1] + out$sims.list$mu.pB1[,1,2,2]+
                out$sims.list$mu.pB1[,2,2,1] + out$sims.list$mu.pB1[,2,2,2])/4
# female - male
B.resight[,2]<- (out$sims.list$mu.pB1[,1,1,1] + out$sims.list$mu.pB1[,1,1,2]+
                 out$sims.list$mu.pB1[,1,2,1] + out$sims.list$mu.pB1[,1,2,2])/4 -
              (out$sims.list$mu.pB1[,2,1,1] + out$sims.list$mu.pB1[,2,1,2]+
                 out$sims.list$mu.pB1[,2,2,1] + out$sims.list$mu.pB1[,2,2,2])/4

# high effort - low effort
B.resight[,3]<- (out$sims.list$mu.pB1[,1,1,2] + out$sims.list$mu.pB1[,2,1,2]+
                 out$sims.list$mu.pB1[,1,2,2] + out$sims.list$mu.pB1[,2,2,2])/4 -
              (out$sims.list$mu.pB1[,1,1,1] + out$sims.list$mu.pB1[,2,1,1]+
                out$sims.list$mu.pB1[,1,2,1] + out$sims.list$mu.pB1[,2,2,1])/4

stats <- data.frame(pval=NA, lci=NA, uci=NA)

# combine survival posteriors
temp.df<- data.frame(Draws=O.surv[,1], Cat="Hacked", State="First-year")
temp.df1<- data.frame(Draws=O.surv[,2], Cat="Sex", State="First-year")
temp.df2<- data.frame(Draws=B.surv[,1], Cat="Hacked", State="Breeder")
temp.df3<- data.frame(Draws=B.surv[,2], Cat="Sex", State="Breeder")
temp.df4<- data.frame(Draws=A.surv[,1], Cat="Hacked", State="Nonbreeder")
temp.df5<- data.frame(Draws=A.surv[,2], Cat="Sex", State="Nonbreeder")
df.surv<- rbind(temp.df, temp.df1, temp.df2, temp.df3, temp.df4, temp.df5)
df.surv$combined<- factor(paste(df.surv$State, df.surv$Cat))
df.surv$combined <- factor(df.surv$combined, levels=levels(df.surv$combined)[c(3,4,5,6,1,2)])

# combine recruitment posteriors
temp.df<- data.frame(Draws=O.rec[,1], Cat="Hacked", State="First-year")
temp.df1<- data.frame(Draws=O.rec[,2], Cat="Sex", State="First-year")
temp.df2<- data.frame(Draws=B.rec[,1], Cat="Hacked", State="Breeder")
temp.df3<- data.frame(Draws=B.rec[,2], Cat="Sex", State="Breeder")
temp.df4<- data.frame(Draws=A.rec[,1], Cat="Hacked", State="Nonbreeder")
temp.df5<- data.frame(Draws=A.rec[,2], Cat="Sex", State="Nonbreeder")
df.rec<- rbind(temp.df, temp.df1, temp.df2, temp.df3, temp.df4, temp.df5)
df.rec$combined<- factor(paste(df.rec$State, df.rec$Cat))
df.rec$combined <- factor(df.rec$combined, levels=levels(df.rec$combined)[c(3,4,5,6,1,2)])

# combine resight posteriors
temp.df2<- data.frame(Draws=B.resight[,1], Cat="Hacked", State="Breeder")
temp.df3<- data.frame(Draws=B.resight[,2], Cat="Sex", State="Breeder")
temp.df4<- data.frame(Draws=B.resight[,3], Cat="Effort", State="Breeder")
temp.df5<- data.frame(Draws=A.resight[,1], Cat="Hacked", State="Nonbreeder")
temp.df6<- data.frame(Draws=A.resight[,2], Cat="Sex", State="Nonbreeder")
temp.df7<- data.frame(Draws=A.resight[,3], Cat="Effort", State="Nonbreeder")
df.resight<- rbind(temp.df2, temp.df3, temp.df4, temp.df5, temp.df6, temp.df7)
df.resight$combined<- factor(paste(df.resight$State, df.resight$Cat))
df.resight$combined <- factor(df.resight$combined, levels=c(levels(df.resight$combined)[c(4,5,6,1,2,3)])) 
# print median and 95% HDIs
ests <- data.frame(round(rbind(
  do.call(rbind, tapply(df.surv$Draws, df.surv$combined, data_summary)),
  do.call(rbind, tapply(df.rec$Draws, df.rec$combined, data_summary)),
  do.call(rbind, tapply(df.resight$Draws, df.resight$combined, data_summary))
),3))
colnames(ests) <- c("median", "LHDI_95", "UHDI_95")
ests$param <- c(rep("survival", 6), rep("recruitment", 6), rep("resight", 6) )
ests$important <- ifelse((ests$LHDI_95 >= 0 & ests$UHDI_95>=0) |
                         (ests$LHDI_95 <= 0 & ests$UHDI_95<=0), 
                         "yes", "no") 
```



## 2.3 The Importance of Covariates in the Global CJS Survival Model
We plot the differences in survival, recruitment, and resight probabilities and evaluate their importance when 85% highest density intervals did not intersect zero.
```{r survdiffs1, fig.width=10, fig.height=10}
print(ests)

```

 
```{r survdiffs2, fig.width=10, fig.height=10, fig.cap= "Fig SX. Violin plots of differences in survival, recruitment, and recapture estimates from global CJS survival submodel."}
txt <- 30
lwd <- 1.5
df.surv$State <- factor(df.surv$State, levels=c("First-year", "Nonbreeder", "Breeder"))

ps <- ggplot(df.surv, aes(x = combined, y = Draws, group=combined )) +
  scale_y_continuous(breaks=c(-0.5, 0, 0.5),  labels=c(-0.5, 0, 0.5)) +
  geom_hline(yintercept=0, linetype="solid", size=lwd) +
  geom_violin(aes(fill=State)) + scale_fill_manual(values=c("#f7f7f7", "#cccccc", "#969696")) +
  stat_summary(fun.data=data_summary,  geom="pointrange", size=lwd) +
  theme_classic() + theme (text = element_text(size=txt)) +  
  ylab("Survival\ndifference") + xlab ("") + 
  scale_x_discrete( labels=c("Hacked", "Sex", "Hacked", "Sex","Hacked", "Sex" )) 
  
pt <- ggplot(df.rec, aes(x = combined, y = Draws, group=combined )) +
  scale_y_continuous(breaks=c(-0.5, 0, 0.5),  labels=c(-0.5, 0, 0.5)) +
  geom_hline(yintercept=0, linetype="solid", size=lwd) +
  geom_violin(aes(fill=State)) +  scale_fill_manual(values=c("#f7f7f7", "#cccccc", "#969696")) + 
  stat_summary(fun.data=data_summary,  geom="pointrange", size=lwd) +
  theme_classic() + theme (text = element_text(size=txt)) +
  ylab("Recruitment\ndifference") + xlab ("") + 
  scale_x_discrete( labels=c("Hacked", "Sex", "Hacked", "Sex","Hacked", "Sex" ))

pr <- ggplot(df.resight, aes(x = combined, y = Draws, group=combined)) +
  scale_y_continuous(breaks=c(-0.5, 0, 0.5),  labels=c(-0.5, 0, 0.5)) +
  geom_hline(yintercept=0, linetype="solid", size=lwd) +
  geom_violin(aes(fill=State)) +  scale_fill_manual(values=c( "#cccccc", "#969696")) +
  stat_summary(fun.data=data_summary,  geom="pointrange", size=lwd) +
  theme_classic() + theme (text = element_text(size=txt)) +
  ylab("Resight\ndifference") + xlab ("") + 
  scale_x_discrete( labels=c("Effort", "Hacked", "Sex", "Effort", "Hacked", "Sex" )) 

grid.arrange(ps + theme(legend.position=c(0.5,0.95), legend.direction="horizontal",legend.background = element_rect(fill = "transparent")), 
             pt + theme(legend.position="none"), 
             pr + theme(legend.position="none"), 
             nrow=3,
             layout_matrix = rbind(c(1, 1, 1, 1, 1, 1),
                                   c(2, 2, 2, 2, 2, 2),
                                   c(3, 3, 3, 3, 3, 3))) 

```


# 3. Implementation of the CJS Survival Model with Reduced Covariates  

## 3.1 JAGS and R Code for the CJS Survival Model with Reduced Covariates
We reduce the number of covariates using probability of direction calculations from the global model. We reduce the survival model, by eliminating covariates that were not important. 
```{r reducedmod, message=FALSE, eval=FALSE}
library (jagsUI)
load(".//data//final-data.Rdata")
m<- c("surv7-jags-reduced")
modfl <- paste(".//", m, ".txt", sep="")
sink(modfl)
cat("
    model{
    ####################################################
    ####################################################
    # Mark-resight-recovery data
    #   Observations (O) = y  
    #     1 seen first year (age 0)
    #     2 seen nonbreeder
    #     3 seen breeder
    #     4 recovered dead
    #     5 not seen
    #   States (S)
    #     1 alive first year
    #     2 alive nonbreeder
    #     3 alive breeder
    #     4 dead
    #     5 dead not recovered
    #     6 emigrated alive
    #     7 emigrated dead
    #   Groups
    #     1 wild born
    #     2 hacked
    #   Sex
    #     1 female
    #     2 male
    #   Effort
    #     1 low
    #     2 high
    ###################################################
    # PARAMETERS
    #   sO: survival probability first year 
    #       (sO as in the letter O rather than zero so jags can parse)
    #   sA: survival probability nonbreeders
    #   sB: survival probability breeders
    #   psiOB: recruitment probability from first-year to breeder
    #   psiAB: recruitment probability from nonbreeders to breeder
    #   psiBA: recruitment probability from breeder to nonbreeders 
    #   pO: resight probability first-year
    #   pA: resight probability nonbreeders
    #   pB: resight probability breeder
    #   em: probability of emigration
    #   r: probability of dead recovery
    ###################################################
    # Priors and constraints
    ###################################################
    l.mu.em <- logit(mu.em)
    mu.em ~ dunif(0,1)

    sigma.AS.s ~ dunif(0,10)
    ASalpha <- logit(ASalpha1)
    ASalpha1 ~ dunif(0, 1)
    
    sigma.BS.s ~ dunif(0,10)
    BSalpha <- logit(BSalpha1) 
    BSalpha1 ~ dunif(0, 1)
    
    sigma.BAR.psi ~ dunif(0,10)
    BARalpha <- logit(BARalpha1)
    BARalpha1 ~ dunif(0, 1)
    r ~ dunif(0, 1)
    sigma.pB ~ dunif(0,10)
    sigma.pA ~ dunif(0,10)
    
    for (k in 1:2){
    mu.pB[k]<- logit(mu.pB1[k])
    mu.pB1[k] ~ dunif(0, 1)
    mu.pA[k] <- logit(mu.pA1[k])
    mu.pA1[k] ~ dunif(0,1)
    } # k
    
    for (t in 1:(n.yr-1)){
    logit(eta.ASalpha[t]) <- ASalpha + eps.AS.s[t]
    eps.AS.s[t] ~ dnorm(0, 1/(sigma.AS.s*sigma.AS.s))
    logit(eta.BSalpha[t]) <- BSalpha + eps.BS.s[t]
    eps.BS.s[t] ~ dnorm(0, 1/(sigma.BS.s*sigma.BS.s))    
    logit(eta.BARalpha[t]) <- BARalpha + eps.BAR.psi[t]
    eps.BAR.psi[t] ~ dnorm(0, 1/(sigma.BAR.psi*sigma.BAR.psi))
    logit(eta.pB[t]) <- mu.pB[effort[t]] + eps.pB[t]
    eps.pB[t] ~ dnorm(0, 1/(sigma.pB*sigma.pB))
    } #t
    
    for(s in 1:2){
    sigma.OS.s[s] ~ dunif(0,10)
    OSalpha[s] <- logit(OSalpha1[s]) 
    OSalpha1[s] ~ dunif(0, 1)
    sigma.OBR.psi[s] ~ dunif(0,10)
    OBRalpha[s] <- logit(OBRalpha1[s]) 
    OBRalpha1[s] ~ dunif(0, 1)
    
    for (t in 1:(n.yr-1)){
    logit(eta.OSalpha[s,t]) <- OSalpha[s] + eps.OS.s[s,t]
    eps.OS.s[s,t] ~ dnorm(0, 1/(sigma.OS.s[s]*sigma.OS.s[s]))
    logit(eta.OBRalpha[s,t]) <- OBRalpha[s] + eps.OBR.psi[s,t]
    eps.OBR.psi[s,t] ~ dnorm(0, 1/(sigma.OBR.psi[s]*sigma.OBR.psi[s]))
    } #t
    
    for (h in 1:2){
    sigma.ABR.psi[s,h] ~ dunif(0,10)
    ABRalpha[s,h] <- logit(ABRalpha1[s,h])
    ABRalpha1[s,h] ~ dunif(0, 1)
    
    for (t in 1:(n.yr-1)){
    logit(eta.ABRalpha[s,h,t]) <- ABRalpha[s,h] + eps.ABR.psi[s,h,t]
    eps.ABR.psi[s,h,t] ~ dnorm(0, 1/(sigma.ABR.psi[s,h]*sigma.ABR.psi[s,h]))
    } } }   #t #h #s
    
    for (t in 1:(n.yr-1)){
    logit(eta.pA[t]) <- mu.pA[effort[t]] + eps.pA[t]
    eps.pA[t] ~ dnorm(0, 1/(sigma.pA*sigma.pA)) 
    logit(em[t]) <-  l.mu.em # eps.em[t]    
} #t 
    
    ################################
    # Likelihood for survival
    ################################
    for (i in 1:nind){
    for (t in 1:(n.yr-1)){
    #Survival
    sO[i,t] <- eta.OSalpha[sex[i],t] # first year
    sA[i,t] <- eta.ASalpha[t] # nonbreeder
    sB[i,t] <- eta.BSalpha[t] # breeder
    #Recruitment
    psiOB[i,t] <- eta.OBRalpha[sex[i],t] # first year to breeder
    psiAB[i,t] <- eta.ABRalpha[sex[i], hacked[i],t] # nonbreeder to breeder
    psiBA[i,t] <- eta.BARalpha[t] # breeder to nonbreeder
    #Re-encounter
    pA[i,t] <- eta.pA[t] # resight of nonbreeders
    pB[i,t] <- eta.pB[t]  # resight of breeders
    }#t
    }#i
    
    # Define state-transition and observation matrices
    for (i in 1:nind){  
    # Define probabilities of state S(t+1) given S(t)
    for (t in first[i]:(n.yr-1)){
    ps[1,i,t,1] <- 0
    ps[1,i,t,2] <- sO[i,t] * (1-psiOB[i,t]) * (1-em[t])
    ps[1,i,t,3] <- sO[i,t] * psiOB[i,t] * (1-em[t])
    ps[1,i,t,4] <- (1-sO[i,t]) * r * (1-em[t])
    ps[1,i,t,5] <- (1-sO[i,t]) * (1-r) * (1-em[t])
    ps[1,i,t,6] <- sO[i,t] * em[t]
    ps[1,i,t,7] <- (1-sO[i,t]) * (1-r) * em[t]
    
    ps[2,i,t,1] <- 0
    ps[2,i,t,2] <- sA[i,t] * (1-psiAB[i,t]) * (1-em[t])
    ps[2,i,t,3] <- sA[i,t] * psiAB[i,t] * (1-em[t])
    ps[2,i,t,4] <- (1-sA[i,t]) * r * (1-em[t])
    ps[2,i,t,5] <- (1-sA[i,t]) * (1-r) * (1-em[t])
    ps[2,i,t,6] <- sA[i,t] * em[t]
    ps[2,i,t,7] <- (1-sA[i,t]) * (1-r) * em[t]
    
    ps[3,i,t,1] <- 0
    ps[3,i,t,2] <- sB[i,t] * psiBA[i,t] * (1-em[t])
    ps[3,i,t,3] <- sB[i,t] * (1-psiBA[i,t]) * (1-em[t])
    ps[3,i,t,4] <- (1-sB[i,t]) * r * (1-em[t])
    ps[3,i,t,5] <- (1-sB[i,t]) * (1-r) * (1-em[t])
    ps[3,i,t,6] <- sB[i,t] * em[t]
    ps[3,i,t,7] <- (1-sB[i,t]) * (1-r) * em[t]
    
    ps[4,i,t,1] <- 0
    ps[4,i,t,2] <- 0
    ps[4,i,t,3] <- 0
    ps[4,i,t,4] <- 0
    ps[4,i,t,5] <- 1
    ps[4,i,t,6] <- 0
    ps[4,i,t,7] <- 0
    
    ps[5,i,t,1] <- 0
    ps[5,i,t,2] <- 0
    ps[5,i,t,3] <- 0
    ps[5,i,t,4] <- 0
    ps[5,i,t,5] <- 1
    ps[5,i,t,6] <- 0
    ps[5,i,t,7] <- 0
    
    ps[6,i,t,1] <- 0
    ps[6,i,t,2] <- 0
    ps[6,i,t,3] <- 0
    ps[6,i,t,4] <- 0
    ps[6,i,t,5] <- 0
    ps[6,i,t,6] <- 1
    ps[6,i,t,7] <- 0
    
    ps[7,i,t,1] <- 0
    ps[7,i,t,2] <- 0
    ps[7,i,t,3] <- 0
    ps[7,i,t,4] <- 0
    ps[7,i,t,5] <- 0
    ps[7,i,t,6] <- 0
    ps[7,i,t,7] <- 1
    
    # Define probabilities of O(t) given S(t)
    po[1,i,t,1] <- 1 
    po[1,i,t,2] <- 0
    po[1,i,t,3] <- 0
    po[1,i,t,4] <- 0
    po[1,i,t,5] <- 0
    
    po[2,i,t,1] <- 0
    po[2,i,t,2] <- pA[i,t]
    po[2,i,t,3] <- 0
    po[2,i,t,4] <- 0
    po[2,i,t,5] <- 1-pA[i,t]
    
    po[3,i,t,1] <- 0
    po[3,i,t,2] <- 0
    po[3,i,t,3] <- pB[i,t]
    po[3,i,t,4] <- 0
    po[3,i,t,5] <- 1-pB[i,t]
    
    po[4,i,t,1] <- 0
    po[4,i,t,2] <- 0
    po[4,i,t,3] <- 0
    po[4,i,t,4] <- 1
    po[4,i,t,5] <- 0
    
    po[5,i,t,1] <- 0
    po[5,i,t,2] <- 0
    po[5,i,t,3] <- 0
    po[5,i,t,4] <- 0
    po[5,i,t,5] <- 1
    
    po[6,i,t,1] <- 0
    po[6,i,t,2] <- 0
    po[6,i,t,3] <- 0
    po[6,i,t,4] <- 0
    po[6,i,t,5] <- 1
    
    po[7,i,t,1] <- 0
    po[7,i,t,2] <- 0
    po[7,i,t,3] <- 0
    po[7,i,t,4] <- 0
    po[7,i,t,5] <- 1
    } #t
    } #i
    
    # Likelihood 
    for (i in 1:nind){
    # Define latent state at first capture
    z[i,first[i]] <- y[i,first[i]]
    for (t in (first[i]+1):n.yr){
    # State process: draw S(t) given S(t-1)
    z[i,t] ~ dcat(ps[z[i,t-1], i, t-1, 1:7])
    # Observation process: draw O(t) given S(t)
    y[i,t] ~ dcat(po[z[i,t], i, t-1, 1:5])
    } #t
    } #i
    } #model
    ",fill = TRUE)
sink()  

# Initial values
get.first <- function(x) min(which(x!=5))
f <- apply(datl$y, 1, get.first)
get.last <- function(x) max(which(x!=5))
l <- apply(datl$y, 1, get.last)
TFmat <- is.na(z.inits) & is.na(datl$z)
for (i in 1:dim(TFmat)[1]){  TFmat[i,1:f[i]] <- FALSE }
z.inits[TFmat] <- sample(size=445, c(2,3), replace=T, prob=c(0.5, 0.5) ) 

inits <- function(){list(z = z.inits)} 

params <- c(
  "r", "l.mu.em", "mu.em", "em",
  "OSalpha", "ASalpha", "BSalpha", "OBRalpha", "ABRalpha", "BARalpha",  "mu.pA", "mu.pB",
  "OSalpha1", "ASalpha1", "BSalpha1","OBRalpha1", "ABRalpha1", "BARalpha1","mu.pA1", "mu.pB1",
  "eps.OS.s", "eps.AS.s", "eps.BS.s", "eps.OBR.psi", "eps.ABR.psi", "eps.BAR.psi", "eps.pA", "eps.pB", 
  "eta.OSalpha", "eta.ASalpha", "eta.BSalpha", "eta.OBRalpha", "eta.ABRalpha", "eta.BARalpha", "eta.pA",  "eta.pB", 
  "sigma.OS.s", "sigma.AS.s", "sigma.BS.s", "sigma.OBR.psi", "sigma.ABR.psi", "sigma.BAR.psi", "sigma.pA", "sigma.pB"  
)

# MCMC settings
# ni <- 200000; nt <- 100; nb <- 100000; nc <- 3; na <- 10000 # actual run # takes about 1 week on a high performance computer
ni <- 10000; nt <- 1; nb <- 5000; nc <- 1; na <- 100 # time-saving run, but inadequate for convergence
out <- jags(datl, inits, params, modfl,  
            n.chains = nc, n.thin = nt, n.burnin = nb, n.adapt=na, n.iter=ni, 
            parallel=T, module=c("glm", "bugs"))
save(file=paste("./", m, ".Rdata", sep=""), list="out")

```
