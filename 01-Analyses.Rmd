---
title: "Appendix S1. Estimating Aplomado Falcon Vital Rates using Cormack-Jolly-Seber and Integrated Population Models"
knit: (function(input_file, encoding) {
  out_dir <- 'docs';
  rmarkdown::render(input_file,
 encoding=encoding,
 output_file=file.path(dirname(input_file), out_dir, 'index.html'))})
author: "Brian W. Rolek"
date: "17 June 2022"
output:
  html_document:
    df_print: paged
    toc: yes
  github_document:
    toc: yes
---

<style type="text/css">
  body{
  font-size: 16pt;
}
</style>


```{r setup, include=FALSE, error=TRUE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r, include=FALSE, cache=FALSE}
knitr::read_chunk('R/01-run-survival-global-JAGS.R')
```

Supplemental materials for: B. W. Rolek, B. Pauli, A. Macias-Duarte, B. Mutch, P. Juergens, T. Anderson, C. Parish, J. Johnson, B. Millsap, C. J. W. McClure. 2022. Long-term Demography of a Reintroduced and Isolated Population of Endangered Falcons. Global Ecology and Conservation.

Metadata (see Readme), data, and scripts used in analyses can be found at https://github.com/The-Peregrine-Fund/Aplomado-Falcon-IPM


# 1 Preliminary Analyses

## 1.1 Overview: Selecting Covariates for Survival, Recruitment, and Resight Probabilities 

Preliminary analyses had two primary components: (1) an evaluation of the probabilities of survival, recruitment, and resight in response to explanatory variables (i.e. hacked, sex, and effort) for each life stage; and (2) an evaluation of emigration and immigration probabilities. For the evaluation of survival, recruitment, and resight response to explanatory variables (1) we used a state-space formulation of a Cormack-Jolly-Seber survival model (hereafter CJS, Gimenez et al. 2007, Royle 2008) with capture-mark-resight-dead recovery data (Kéry and Schaub 2012).

We implemented a preliminary CJS model using the global model that included all discrete explanatory variables considered here as fixed effects for survival, recruitment, and resight probabilities. The explanatory variable ‘sex’ indexed the mean intercept of survival, recruitment, and resight probabilities as either female or male; ‘hacked status’ indexed the mean intercept of survival, recruitment, and resight probabilities as either wild or hacked; and ‘survey effort’ indexed the mean intercept of resight probabilities in a given year as low or high effort. Additionally, we included these explanatory variables as indices of the standard errors ($σ$) associated with the random factor for each year, allowing groups (e.g. male and female) to have different standard errors over time. 

We used the preliminary CJS model that included all explanatory variables to estimate whether parameters were important by calculating the difference between pairs of groups (e.g. male and female, Kruschke 2011, McClure et al. 2017b) using their posterior distributions and retained important covariates when 85% highest density intervals (HDIs) of these differences did not intersect zero. We retained important explanatory variables within a CJS survival model for use in subsequent IPMs (Appendix S1: Table S1 and Fig. S1). This CJS model included five observation states and seven true states that allowed for the estimation of emigration and true survival (see S1 Section 1 for details).

## 1.2 Overview: Immigration and Emigration Rates 

We estimated emigration from an integrated population model by using mark-resight-dead recovery data (p. 241, Kéry and Schaub 2012). We did not have explicit data on immigration; however, IPMs can estimate a latent vital rate when all other vital rates were measured empirically (Kéry and Schaub 2012); therefore, we used a model-based method to estimate the number of immigrants ($N^I$, denoted with superscript I) and an immigration rate ($ω$, Abadi et al. 2010) of adults (non-breeders and breeders). First-years must be recruited as either breeders or non-breeders during the following post-breeding survey; therefore, we did not include immigration of first-years. We constructed an identical IPM to the one described below (see Integrated Population Model), except that we included an immigration rate parameter. We used this preliminary IPM analysis to assess whether inclusion of immigration rates could bias estimation of vital rates (Schaub and Fletcher 2015), and excluded immigration rates if they were negligible (median immigration rate ≤ 0.01), and when density plots of posterior distributions of survival did not visually differ. 

Including latent immigration rates in IPMs when populations are isolated could bias estimates (Schaub and Fletcher 2015; Paquet et al. 2021) because immigration rates were constrained to positive values. Therefore, we excluded immigration from final analyses if estimates were too imprecise or biologically implausible.

## 1.3 Formulation of Multi-state Cormack-Jolly-Seber (CJS) Model with Emigration
The formulation of the CJS model with emigration is included in the Methods section of the manuscript. We review the basic structure here.

### 1.3.1 Observation Matrix  
We specified the observation matrix ($PO$) that relates observed states (columns) to real states (rows) of Northern Aplomado Falcons.  
Observed states (1--5, columns left to right):  
1.  Seen first-year  
2.  Seen non-breeder  
3.  Seen breeder  
4.  Seen dead  
5.  Not seen  

True states (1--7, rows top to bottom):  
1.  First-year  
2.  Non-breeder  
3.  Breeder  
4.  Recovered recently dead   
5.  Dead not recovered  
6.  Emigrated and alive  
7.  Emigrated and dead  

where superscripts with capital letters are used as labels for life cycle states: first-year ($O$), non-breeder ($A$), and breeder ($B$). Observations are related to true states using transition and resight probabilities ($p$) for non-breeder ($p^A$) and breeders ($p^B$):
$$PO=
\begin{bmatrix} 
1 & 0 & 0 & 0 & 0\\
0 & p^A & 0 & 0 & 1-p^A\\
0 & 0 & p^B & 0 & 1-p^B\\
0 & 0 & 0 & 1 & 0\\
0 & 0 & 0 & 0 & 1\\
0 & 0 & 0 & 0 & 1\\
0 & 0 & 0 & 0 & 1\\
\end{bmatrix}
$$
We assume perfect resight probability (1.0 at row 1 and column 1) because these birds must be captured during their first observation. 

### 1.3.2 State-Transition Matrix  
Next, we specified the state-transition matrix ($\Omega$) that governs dynamics between true states over time. Rows of the matrix represent true states during time step ($t$), and columns represent true states during the following time step ($t+1$). Each row and column number correspond to true states listed above. For example, row 1 corresponds with first-years at time t and column 1 corresponds with first-years at time t+1. Here, $r$ is the recapture probability of a recently dead bird and $\delta$ is the probability of emigration. 

$$ \Omega=
\begin{bmatrix} 
0 & \phi^0(1-\psi^{0B})(1-\delta)  & \phi^0\psi^{0B}(1-\delta) & (1-\phi^0)r(1-\delta) & (1-\phi^0)(1-r)(1-\delta) & \phi^0\delta & (1-\phi^0)(1-r)\delta\\ 
0 & \phi^{AB}(1-\psi^{AB})(1-\delta)  & \phi^A\psi^{AB}(1-\delta) & (1-\phi^A)r(1-\delta) & (1-\phi^A)(1-r)(1-\delta) & \phi^A\delta & (1-\phi^A)(1-r)\delta\\ 
0 & \phi^B\psi^{BA}(1-\delta)  & \phi^B(1-\psi^{BA})(1-\delta) & (1-\phi^B)r(1-\delta) & (1-\phi^B)(1-r)(1-\delta) & \phi^B\delta & (1-\phi^B)(1-r)\delta\\ 
0 & 0 & 0 & 0 & 1 & 0 & 0\\
0 & 0 & 0 & 0 & 1 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 1 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 1\\
\end{bmatrix}
$$

### 1.3.3 CJS Model with Global Constraints (Includes All Group Covariates)  
We implemented the global CJS model in Just Another Gibbs Sampler (JAGS). The "global survival model" includes all covariates considered here. Probabilities of survival ($\phi$), recruitment ($\psi$), and resight ($p$) are contrained to vary by sex ($s$, male or female), hacked ($h$, wild-born or captive bred). Each life stage (first-year, non-breeder, breeder) and group (sex, hacked, effort) has a unique variance parameter over time. We used the same constraints for first-year, non-breeder, and breeder birds. Superscripts with Greek symbols are used to label parameters. 
$$logit(\phi_{i,t})=\mu_{s,h}^{\phi} + \epsilon_{s,h,t}^{\phi}$$
$$\epsilon_{s,h,t}^{\phi}=normal(0,\tau=1/\sigma_{s,h}^{\phi,2})$$ 
$$logit(\psi_{i,t})=\mu_{s,h}^{\psi} + \epsilon_{s,h,t}^{\psi}$$

$$\epsilon_{s,h,t}^{\psi}=normal(0,\tau=1/\sigma_{s,h}^{\psi,2})$$ 
Furthermore, probability of resight varied by survey effort ($e$) for non-breeders and breeders. 
$$logit(p_{i,t})=\mu_{s,h,e}^{p} + \epsilon_{s,h,t}^{p}$$
$$\epsilon_{s,h,t}^{p}=normal(0,\tau=1/\sigma_{s,h}^{p,2})$$ 
Probabilities of emigration ($\delta$) and dead recovery ($r$) are contrained to an overall mean $\mu$. 
$$logit(\delta_{i,t})=\mu^{\delta}$$
Including emigration within this model allowed us to estimate _true_ survival rather than _apparent_ survival, because apparent survival is confounded with emigration (1-site fidelity) in some CJS models. 

## 1.4 Implementation of the Multi-state CJS Model with Global Constraints

### 1.4.1 JAGS and R Code for Implementing the CJS Model with Global Constraints

```{r, global, eval=FALSE}
```

### 1.4.2 Postprocess Global Model
We postprocess the output from JAGS to examine differences between sex, hacked, and effort estimates for probabilities of survival, recruitment, resight, and estimate emigration.  

#### 1.4.2.1 Functions to Summarize Posterior Distributions
```{r funcs, message=FALSE}
library (jagsUI)
library (ggplot2)
library (gridExtra)

# Function to compute highest density interval. From Kruschke 2011.
HDIofMCMC = function( sampleVec , credMass=0.95 ) {
  sortedPts = sort( sampleVec )
  ciIdxInc = floor( credMass * length( sortedPts ) )
  nCIs = length( sortedPts ) - ciIdxInc
  ciWidth = rep( 0 , nCIs )
  for ( i in 1:nCIs ) {
    ciWidth[ i ] = sortedPts[ i + ciIdxInc ] - sortedPts[ i ]
  }
  HDImin = sortedPts[ which.min( ciWidth ) ]
  HDImax = sortedPts[ which.min( ciWidth ) + ciIdxInc ]
  HDIlim = c( HDImin , HDImax )
  return( HDIlim )
}

# Function to compute summary stats over posteriors
data_summary <- function(x,...) {
  m <- median(x)
  ymin <- HDIofMCMC(x, credMass=0.95)[[1]]
  ymax <- HDIofMCMC(x, credMass=0.95)[[2]]
  return(c(y=m,ymin=ymin,ymax=ymax))
}

data_summary2 <- function(x,...) {
  m <- median(x)
  ymin <- HDIofMCMC(x, credMass=0.85)[[1]]
  ymax <- HDIofMCMC(x, credMass=0.85)[[2]]
  return(c(y=m,ymin=ymin,ymax=ymax))
}
```

#### 1.4.2.2 Calculate Differences Between Groups  

We load the results from the global CJS model to assess which covariates had important effects on parameters.

```{r ppsurvival, eval=TRUE}
load(".\\outputs\\surv7-em-global.Rdata")


O.surv <- O.rec <- A.surv <- A.rec <- B.surv <- B.rec <- array(NA, dim=c(dim(out$sims.list$OSalpha1)[1],3))
A.resight <- B.resight <-array(NA, dim=c(dim(out$sims.list$mu.pA1)[1],3))

##########################
# First-year (O) capital letter o, rather than zero so code works 
#########################
# Survival
# wild - hacked
O.surv[,1]<- (out$sims.list$OSalpha1[,1,1] +         out$sims.list$OSalpha1[,2,1])/2 -
  (out$sims.list$OSalpha1[,1,2] + out$sims.list$OSalpha1[,2,2])/2
# female - male
O.surv[,2]<- (out$sims.list$OSalpha1[,1,1] + out$sims.list$OSalpha1[,1,2])/2 -
  (out$sims.list$OSalpha1[,2,1] + out$sims.list$OSalpha1[,2,2])/2
# Recruitment
# wild - hacked
O.rec[,1]<- (out$sims.list$OBRalpha1[,1,1] + out$sims.list$OBRalpha1[,2,1])/2 -
  (out$sims.list$OBRalpha1[,1,2] + out$sims.list$OBRalpha1[,2,2])/2
# female - male
O.rec[,2]<- (out$sims.list$OBRalpha1[,1,1] + out$sims.list$OBRalpha1[,1,2])/2 -
  (out$sims.list$OBRalpha1[,2,1] + out$sims.list$OBRalpha1[,2,2])/2

##########################
# Adult Nonbreeders (A)
#########################
# Survival
# wild - hacked
A.surv[,1]<- (out$sims.list$ASalpha1[,1,1] + out$sims.list$ASalpha1[,2,1])/2 -
  (out$sims.list$ASalpha1[,1,2] + out$sims.list$ASalpha1[,2,2])/2
# female - male
A.surv[,2]<- (out$sims.list$ASalpha1[,1,1] + out$sims.list$ASalpha1[,1,2])/2 -
  (out$sims.list$ASalpha1[,2,1] + out$sims.list$ASalpha1[,2,2])/2
# Recruitment
# wild - hacked
A.rec[,1]<- (out$sims.list$ABRalpha1[,1,1] + out$sims.list$ABRalpha1[,2,1])/2 -
  (out$sims.list$ABRalpha1[,1,2] + out$sims.list$ABRalpha1[,2,2])/2
# female - male
A.rec[,2]<- (out$sims.list$ABRalpha1[,1,1] + out$sims.list$ABRalpha1[,1,2])/2 -
  (out$sims.list$ABRalpha1[,2,1] + out$sims.list$ABRalpha1[,2,2])/2
# Resight prob
# wild-hacked
A.resight[,1]<- (out$sims.list$mu.pA1[,1,1,1] + out$sims.list$mu.pA1[,1,1,2] + out$sims.list$mu.pA1[,2,1,1] + out$sims.list$mu.pA1[,2,1,2])/4 -
              (out$sims.list$mu.pA1[,1,2,1] + out$sims.list$mu.pA1[,1,2,2]+
                out$sims.list$mu.pA1[,2,2,1] + out$sims.list$mu.pA1[,2,2,2])/4
# female - male
A.resight[,2]<- (out$sims.list$mu.pA1[,1,1,1] + out$sims.list$mu.pA1[,1,1,2]+
                 out$sims.list$mu.pA1[,1,2,1] + out$sims.list$mu.pA1[,1,2,2])/4 -
              (out$sims.list$mu.pA1[,2,1,1] + out$sims.list$mu.pA1[,2,1,2]+
                 out$sims.list$mu.pA1[,2,2,1] + out$sims.list$mu.pA1[,2,2,2])/4

# high effort - low effort
A.resight[,3]<- (out$sims.list$mu.pA1[,1,1,2] + out$sims.list$mu.pA1[,2,1,2]+
                 out$sims.list$mu.pA1[,1,2,2] + out$sims.list$mu.pA1[,2,2,2])/4 -
              (out$sims.list$mu.pA1[,1,1,1] + out$sims.list$mu.pA1[,2,1,1]+
                out$sims.list$mu.pA1[,1,2,1] + out$sims.list$mu.pA1[,2,2,1])/4

##########################
# Adult Breeders (B)
#########################
# Survival
# wild - hacked
B.surv[,1]<- (out$sims.list$BSalpha1[,1,1] + out$sims.list$BSalpha1[,2,1])/2 -
  (out$sims.list$BSalpha1[,1,2] + out$sims.list$BSalpha1[,2,2])/2
# female - male
B.surv[,2]<- (out$sims.list$BSalpha1[,1,1] + out$sims.list$BSalpha1[,1,2])/2 -
  (out$sims.list$BSalpha1[,2,1] + out$sims.list$BSalpha1[,2,2])/2
# Recruitment
# wild - hacked
B.rec[,1]<- (out$sims.list$BARalpha1[,1,1] + out$sims.list$BARalpha1[,2,1])/2 -
  (out$sims.list$BARalpha1[,1,2] + out$sims.list$BARalpha1[,2,2])/2
# female - male
B.rec[,2]<- (out$sims.list$BARalpha1[,1,1] + out$sims.list$BARalpha1[,1,2])/2 -
  (out$sims.list$BARalpha1[,2,1] + out$sims.list$BARalpha1[,2,2])/2
# resight prob  
# wild-hacked
B.resight[,1]<- (out$sims.list$mu.pB1[,1,1,1] + out$sims.list$mu.pB1[,1,1,2] + out$sims.list$mu.pB1[,2,1,1] + out$sims.list$mu.pB1[,2,1,2])/4 -
              (out$sims.list$mu.pB1[,1,2,1] + out$sims.list$mu.pB1[,1,2,2]+
                out$sims.list$mu.pB1[,2,2,1] + out$sims.list$mu.pB1[,2,2,2])/4
# female - male
B.resight[,2]<- (out$sims.list$mu.pB1[,1,1,1] + out$sims.list$mu.pB1[,1,1,2]+
                 out$sims.list$mu.pB1[,1,2,1] + out$sims.list$mu.pB1[,1,2,2])/4 -
              (out$sims.list$mu.pB1[,2,1,1] + out$sims.list$mu.pB1[,2,1,2]+
                 out$sims.list$mu.pB1[,2,2,1] + out$sims.list$mu.pB1[,2,2,2])/4

# high effort - low effort
B.resight[,3]<- (out$sims.list$mu.pB1[,1,1,2] + out$sims.list$mu.pB1[,2,1,2]+
                 out$sims.list$mu.pB1[,1,2,2] + out$sims.list$mu.pB1[,2,2,2])/4 -
              (out$sims.list$mu.pB1[,1,1,1] + out$sims.list$mu.pB1[,2,1,1]+
                out$sims.list$mu.pB1[,1,2,1] + out$sims.list$mu.pB1[,2,2,1])/4

stats <- data.frame(pval=NA, lci=NA, uci=NA)

# combine survival posteriors
temp.df<- data.frame(Draws=O.surv[,1], Cat="Hacked", State="First-year")
temp.df1<- data.frame(Draws=O.surv[,2], Cat="Sex", State="First-year")
temp.df2<- data.frame(Draws=B.surv[,1], Cat="Hacked", State="Breeder")
temp.df3<- data.frame(Draws=B.surv[,2], Cat="Sex", State="Breeder")
temp.df4<- data.frame(Draws=A.surv[,1], Cat="Hacked", State="Non-breeder")
temp.df5<- data.frame(Draws=A.surv[,2], Cat="Sex", State="Non-breeder")
df.surv<- rbind(temp.df, temp.df1, temp.df2, temp.df3, temp.df4, temp.df5)
df.surv$combined<- factor(paste(df.surv$State, df.surv$Cat))
df.surv$combined <- factor(df.surv$combined, levels=levels(df.surv$combined)[c(3,4,5,6,1,2)])

# combine recruitment posteriors
temp.df<- data.frame(Draws=O.rec[,1], Cat="Hacked", State="First-year")
temp.df1<- data.frame(Draws=O.rec[,2], Cat="Sex", State="First-year")
temp.df2<- data.frame(Draws=B.rec[,1], Cat="Hacked", State="Breeder")
temp.df3<- data.frame(Draws=B.rec[,2], Cat="Sex", State="Breeder")
temp.df4<- data.frame(Draws=A.rec[,1], Cat="Hacked", State="Non-breeder")
temp.df5<- data.frame(Draws=A.rec[,2], Cat="Sex", State="Non-breeder")
df.rec<- rbind(temp.df, temp.df1, temp.df2, temp.df3, temp.df4, temp.df5)
df.rec$combined<- factor(paste(df.rec$State, df.rec$Cat))
df.rec$combined <- factor(df.rec$combined, levels=levels(df.rec$combined)[c(3,4,5,6,1,2)])

# combine resight posteriors
temp.df2<- data.frame(Draws=B.resight[,1], Cat="Hacked", State="Breeder")
temp.df3<- data.frame(Draws=B.resight[,2], Cat="Sex", State="Breeder")
temp.df4<- data.frame(Draws=B.resight[,3], Cat="Effort", State="Breeder")
temp.df5<- data.frame(Draws=A.resight[,1], Cat="Hacked", State="Non-breeder")
temp.df6<- data.frame(Draws=A.resight[,2], Cat="Sex", State="Non-breeder")
temp.df7<- data.frame(Draws=A.resight[,3], Cat="Effort", State="Non-breeder")
df.resight<- rbind(temp.df2, temp.df3, temp.df4, temp.df5, temp.df6, temp.df7)
df.resight$combined<- factor(paste(df.resight$State, df.resight$Cat))
df.resight$combined <- factor(df.resight$combined, levels=c(levels(df.resight$combined)[c(4,5,6,1,2,3)])) 
# print median and 95% HDIs
ests <- data.frame(round(rbind(
  do.call(rbind, tapply(df.surv$Draws, df.surv$combined, data_summary)),
  do.call(rbind, tapply(df.rec$Draws, df.rec$combined, data_summary)),
  do.call(rbind, tapply(df.resight$Draws, df.resight$combined, data_summary))
),3))
ests2 <- data.frame(round(rbind(
  do.call(rbind, tapply(df.surv$Draws, df.surv$combined, data_summary2)),
  do.call(rbind, tapply(df.rec$Draws, df.rec$combined, data_summary2)),
  do.call(rbind, tapply(df.resight$Draws, df.resight$combined, data_summary2))
),3))
ests <- cbind(ests, ests2[, c(2,3)])
colnames(ests) <- c("median", "LHDI_95", "UHDI_95", "LHDI_85", "UHDI_85")
ests <- cbind(c(rep("survival", 6), rep("recruitment", 6), rep("resight", 6) ), ests)
colnames(ests)[1] <- "param"
ests$imp95 <- ifelse((ests$LHDI_95 >= 0 & ests$UHDI_95>=0) |                   (ests$LHDI_95 <= 0 & ests$UHDI_95<=0),                          "yes", "no") 
ests$imp85 <- ifelse((ests$LHDI_85 >= 0 & ests$UHDI_85>=0) |                   (ests$LHDI_85 <= 0 & ests$UHDI_85<=0),                          "yes", "no")
```

#### 1.4.2.3 The Importance of Covariates in the CJS Model with Global Constraints
```{r survdiffs1, fig.width=10, fig.height=10}
library (knitr)
knitr::kable(ests, caption="Table S1. Estimates of differences between groups for survival, recruitment, and resight probabilities. We present medians, 95% HDIs, and 85% HDIs. Differences were considered potentially important when 85% highest density intervals did not intersect zero.")

```

 
```{r survdiffs2, fig.width=10, fig.height=10, fig.cap= "Fig. S1. Violin plots of differences in survival, recruitment, and recapture estimates from global CJS survival model. Differences were considered potentially important when 85% highest density intervals did not intersect zero."}
txt <- 30
lwd <- 1.5
df.surv$State <- factor(df.surv$State, levels=c("First-year", "Non-breeder", "Breeder"))

ps <- ggplot(df.surv, aes(x = combined, y = Draws, group=combined )) +
  scale_y_continuous(breaks=c(-0.5, 0, 0.5),  labels=c(-0.5, 0, 0.5)) +
  geom_hline(yintercept=0, linetype="solid", size=lwd) +
  geom_violin(aes(fill=State)) + scale_fill_manual(values=c("First-year"="#f7f7f7",
    "Non-breeder"="#cccccc", "Breeder"="#969696")) +
  stat_summary(fun.data=data_summary2,  geom="pointrange", size=lwd) +
  theme_classic() + theme (text = element_text(size=txt)) +  
  ylab("Survival\ndifference") + xlab ("") + 
  scale_x_discrete( labels=c("Hacked", "Sex", "Hacked", "Sex","Hacked", "Sex" )) 
  
pt <- ggplot(df.rec, aes(x = combined, y = Draws, group=combined )) +
  scale_y_continuous(breaks=c(-0.5, 0, 0.5),  labels=c(-0.5, 0, 0.5)) +
  geom_hline(yintercept=0, linetype="solid", size=lwd) +
  geom_violin(aes(fill=State)) +  scale_fill_manual(values=c("First-year"="#f7f7f7",
    "Non-breeder"="#cccccc", "Breeder"="#969696")) + 
  stat_summary(fun.data=data_summary2,  geom="pointrange", size=lwd) +
  theme_classic() + theme (text = element_text(size=txt)) +
  ylab("Recruitment\ndifference") + xlab ("") + 
  scale_x_discrete( labels=c("Hacked", "Sex", "Hacked", "Sex","Hacked", "Sex" ))

pr <- ggplot(df.resight, aes(x = combined, y = Draws, group=combined)) +
  scale_y_continuous(breaks=c(-0.5, 0, 0.5),  labels=c(-0.5, 0, 0.5)) +
  geom_hline(yintercept=0, linetype="solid", size=lwd) +
  geom_violin(aes(fill=State)) +  scale_fill_manual(values=c("First-year"="#f7f7f7",
    "Non-breeder"="#cccccc", "Breeder"="#969696")) +
  stat_summary(fun.data=data_summary2,  geom="pointrange", size=lwd) +
  theme_classic() + theme (text = element_text(size=txt)) +
  ylab("Resight\ndifference") + xlab ("") + 
  scale_x_discrete( labels=c("Effort", "Hacked", "Sex", "Effort", "Hacked", "Sex" )) 

grid.arrange(ps + theme(legend.position=c(0.5,0.95), legend.direction="horizontal",legend.background = element_rect(fill = "transparent")), 
             pt + theme(legend.position="none"), 
             pr + theme(legend.position="none"), 
             nrow=3,
             layout_matrix = rbind(c(1, 1, 1, 1, 1, 1),
                                   c(2, 2, 2, 2, 2, 2),
                                   c(3, 3, 3, 3, 3, 3))) 

```
#### 1.4.2.4 The Importance of Emigration  
```{r emigration1, fig.width=6, fig.height=4, fig.cap= "Fig. S2. Histogram of emigration. Median (solid line) and 95% HDIs (dashed line) are depicted."}
hist(out$sims.list$em, main="Histogram of Emigration", xlab="Posterior draws of emigration")
abline(v=median(out$sims.list$em), lwd=2)
abline(v=HDIofMCMC(out$sims.list$em, cred=0.95), lty=2, lwd=2)
median(out$sims.list$em)
HDIofMCMC(out$sims.list$em, cred=0.95)
```

```{r emigration2, fig.width=6, fig.height=4, fig.cap= "Fig. S3. Prior and posterior densities of emigration."}
# plot prior of dunif(0,1) and posterior density of emigration
x <- seq(-0.5, 1.5, length=1000)
y <- dunif(x, min = 0, max = 1)
par(mar=c(5,5,2,5))
plot(x, y, type="l", lwd=2, xlim=c(0,1.1),
     ylab="Prior density (black line)\n Uniform(0,1)", 
     xlab=expression(paste("Emigration rate (",delta,")", sep="")),
     main="")
par(new=TRUE)
plot(density(out$sims.list$em), type="l", lwd=2, xlim=c(0,1.1),
     main="", col="blue",
     axes = FALSE, xlab = "", ylab = "")
axis(side = 4, at = c(0,350,700))      # Add second axis
mtext("Posterior density (blue line)", side = 4, line = 3)  

```

## 1.5 Implementation of the Integrated Population Model with Immigration  
We specify the IPM including observation and state-transition matrices for the CJS survival submodel provided within the manuscript. These matrices are identical for IPMs with and without immigration.  

### 1.5.1 Formulation of the IPM with Immigration
This IPM specifies immigration as a rate (Abadi et al. 2010). We estimate this immigration rate ($\omega$) for non-breeders and breeders separately. The number of immigrant breeders ($N_{t+1}^{IB}$) was specified as  

$$N_{t+1}^{IB} \sim {\sf Poisson}(N_{t}^{B}\omega_{t}^{B})$$

We assigned the following prior to immigration rates:
$$ \omega_{t}^{B}= \mu^{IB}+\epsilon_{t}$$ 
$$\mu^{IB}\sim {\sf half normal}(mean=0,sd=1)$$
$$ \epsilon_{t}\sim normal(0, \sigma^{IB})$$
A similar parameterization was used for non-breeder immigration. We did not include immigration of first-year birds because they must be recruited as breeders or non-breeders during the following post-breeding survey. 

### 1.5.2 JAGS and R Code for the IPM with Immigration  

```{r, include=FALSE, cache=FALSE}
knitr::read_chunk('R/03-run-ipm-immigration-JAGS.R')
```
```{r,ipm1, eval=FALSE}
```

### 1.5.3 The Importance of Immigration
```{r,immigration, eval=TRUE}
## ---- immigration ---------
# plot priors and posteriors of immigration
load("outputs\\ipm-ie.Rdata")
source("R/HDIofMCMC.R")
options(scipen = 100)
x <- seq(from=0, to=4, by=0.01)
df <- data.frame(x=x, prior=dnorm(x,0,1))
df2 <- data.frame(omegaA=out$sims.list$omegaA1, 
                  omegaB=out$sims.list$omegaB1)
```

```{r ImmPriorPost1, fig.width=6, fig.height=4, fig.cap= "Fig. S4. Immigration priors and posteriors of nonbreeders.", fig.show="hold", out.width="100%"}
par(mar=c(5,5,2,5))
plot(df$x, df$prior, type="l", lwd=2, xlim=c(0,4),
     ylab="Prior density (black line)", 
     xlab=expression(paste("Immigration rate (",omega,")", sep="")),
     main="Nonbreeders")
par(new=TRUE)
plot(density(df2$omegaA), type="l", lwd=2, xlim=c(0,4),
     main="", col="blue",
     axes = FALSE, xlab = "", ylab = "")
axis(side = 4, at = c(0,30,60))      # Add second axis
mtext("Posterior density (blue line)", side = 4, line = 3)  
```

```{r ImmPriorPost2, fig.width=6, fig.height=4, fig.cap= "Fig. S5. Immigration priors and posteriors of breeders.", fig.show="hold", out.width="100%"}
# Plot immigration of breeders
par(mar=c(5,5,2,5))
plot(df$x, df$prior, type="l", lwd=2, xlim=c(0,4),
     ylab="Prior density (black line)", 
     xlab=expression(paste("Immigration rate (",omega,")", sep="")),
     main="Breeders")
par(new=TRUE)
plot(density(df2$omegaB), type="l", lwd=2, xlim=c(0,4),
     main="", col="blue",
     axes = FALSE, xlab = "", ylab = "")
axis(side = 4, at = c(0,30,60))      # Add second axis
mtext("Posterior density (blue line)", side = 4, line = 3) 
```

```{r ImmHist1, fig.width=6, fig.height=4, fig.cap= "Fig. S6. Histogram and point estimates of Immigration of nonbreeders", fig.show="hold", out.width="100%"}
hist(out$sims.list$omegaA1, main="Histogram of Immigration\nNonbreeders", xlab="Posterior draws of immigration")
abline(v=median(out$sims.list$omegaA1), lwd=2)
abline(v=HDIofMCMC(out$sims.list$omegaA1, cred=0.95), lty=2, lwd=2)
median(out$sims.list$omegaA1)
HDIofMCMC(out$sims.list$omegaA1, cred=0.95)
```

```{r ImmHist2, fig.width=6, fig.height=4, fig.cap= "Fig. S7. Histogram and point estimates of Immigration of breeders", fig.show="hold", out.width="100%"}
hist(out$sims.list$omegaB1, main="Histogram of Immigration\nBreeders", xlab="Posterior draws of immigration")
abline(v=median(out$sims.list$omegaB1), lwd=2)
abline(v=HDIofMCMC(out$sims.list$omegaB1, cred=0.95), lty=2, lwd=2)
median(out$sims.list$omegaB1)
HDIofMCMC(out$sims.list$omegaB1, cred=0.95)
db <- density(out$sims.list$omegaB1)
db$x[which(db$y==max(db$y))]
```

# 2. Implementation of the Integrated Population Model without Immigration for Evaluation of Vital Rates
## 2.1 JAGS and R Code for the IPM without Immigration 
```{r, include=FALSE, cache=FALSE}
knitr::read_chunk('R/04-run-ipm-no-immigration-JAGS.R')
```
```{r,ipm2, eval=FALSE}
```


## 2.2 Postprocess Model Output  
```{r ppipm, eval=TRUE}
load(".\\outputs\\ipm-e.Rdata") # load model output
library (jagsUI)
library (ggplot2)
library (gridExtra)
source("R\\HDIofMCMC.R") # Function to compute highest density interval. From Kruschke 2011.
data_summary85 <- function(x) {
  m <- median(x)
  ymin <- HDIofMCMC(x, credMass=0.85)[[1]]
  ymax <- HDIofMCMC(x, credMass=0.85)[[2]]
  return(c(y=m,ymin=ymin,ymax=ymax))
}

data_summary95 <- function(x) {
  m <- median(x)
  ymin <- HDIofMCMC(x, credMass=0.95)[[1]]
  ymax <- HDIofMCMC(x, credMass=0.95)[[2]]
  return(c(y=m,ymin=ymin,ymax=ymax))
}

O.surv <- O.trans <- A.surv <- A.trans <- B.surv <- B.trans <- 
  array(NA, dim=c(dim(out$sims.list$OSalpha1)[1],3))
B.recap <-array(NA, dim=c(dim(out$sims.list$mu.pB1)[1],2))
A.recap <-array(NA, dim=c(dim(out$sims.list$mu.pA1)[1],2))

# Survival
# wild - hacked
O.surv[,1]<- (out$sims.list$OSalpha1[,1,1] +         out$sims.list$OSalpha1[,2,1])/2 -
  (out$sims.list$OSalpha1[,1,2] + out$sims.list$OSalpha1[,2,2])/2
# female - male
O.surv[,2]<- (out$sims.list$OSalpha1[,1,1] + out$sims.list$OSalpha1[,1,2])/2 -
  (out$sims.list$OSalpha1[,2,1] + out$sims.list$OSalpha1[,2,2])/2
# Recruitment
O.trans[,2]<- out$sims.list$OBRalpha1[,1] - out$sims.list$OBRalpha1[,2]# Recruitment female - male
# Nonbreeder (A) Recruitment
A.trans[,1]<- (out$sims.list$ABRalpha1[,1,1] + out$sims.list$ABRalpha1[,2,1])/2 -
  (out$sims.list$ABRalpha1[,1,2] + out$sims.list$ABRalpha1[,2,2])/2 # wild - hacked
A.trans[,2]<- (out$sims.list$ABRalpha1[,1,1] + out$sims.list$ABRalpha1[,1,2])/2 -
  (out$sims.list$ABRalpha1[,2,1] + out$sims.list$ABRalpha1[,2,2])/2 # female - male
# Resight probabilities of nonbreeders indexed as mu.pA1 [effort, h]
A.recap[,1] <- (out$sims.list$mu.pA1[,1,1] + out$sims.list$mu.pA1[,2,1])/2 - 
              (out$sims.list$mu.pA1[,1,2] + out$sims.list$mu.pA1[,2,2])/2 # wild - hacked
A.recap[,2] <- (out$sims.list$mu.pA1[,2,1] + out$sims.list$mu.pA1[,2,2])/2 - 
            (out$sims.list$mu.pA1[,1,1] + out$sims.list$mu.pA1[,1,2])/2 # high effort - low # Resight probabilities of nonbreeders indexed as mu.pB1 [effort]
B.recap[,1] <- out$sims.list$mu.pB1[,2] - out$sims.list$mu.pB1[,1] # high effort - low effort

tab <- data.frame(stage= c("First-year", "First-year", "First-year", "Nonbreeder", "Nonbreeder", "Nonbreeder", "Nonbreeder", "Breeder"),
                  param= c("Survival", "Survival","Recruitment", "Recruitment", "Recruitment", "Resight", "Resight", "Resight"),
                  comp= c("Sex", "Hacked", "Sex", "Hacked", "Sex", "Hacked", "Effort", "Effort" ),
                  median=NA, LHDI95=NA, UHDI95=NA, P=NA, important=NA)
tab[1, 4:6]<- round(data_summary95(O.surv[,2]),3)
tab[2, 4:6]<- round(data_summary95(O.surv[,1]),3)
tab[3, 4:6]<- round(data_summary95(O.trans[,2]),3)
tab[4, 4:6]<- round(data_summary95(A.trans[,1]),3)
tab[5, 4:6]<- round(data_summary95(A.trans[,2]),3)
tab[6, 4:6]<- round(data_summary95(A.recap[,1]),3)
tab[7, 4:6]<- round(data_summary95(A.recap[,2]),3)
tab[8, 4:6]<- round(data_summary95(B.recap[,1]),3)
tab$important <- ifelse( ((tab$LHDI95 >= 0 & tab$UHDI95>=0) |
                             (tab$LHDI95 <= 0 & tab$UHDI95<=0)) &
                            (tab$LHDI95 != 0 & tab$UHDI95!=0), 
                          "yes", "no") 
tab$P[1] <- round(sum(O.surv[,2]>0)/length(O.surv[,2]),2)
tab$P[2] <- round(sum(O.surv[,2]>0)/length(O.surv[,1]),2)
tab$P[3] <- round(sum(O.trans[,2]<0)/length(O.trans[,2]),2)
tab$P[4] <- round(sum(A.trans[,1]>0)/length(A.trans[,1]),2)
tab$P[5] <- round(sum(A.trans[,2]<0)/length(A.trans[,2]),2)
tab$P[6] <- round(sum(A.recap[,1]>0)/length(A.recap[,1]),2)
tab$P[7] <- round(sum(A.recap[,2]>0)/length(A.recap[,2]),2)
tab$P[8] <- round(sum(B.recap[,1]>0)/length(B.recap[,1]),2)
print(tab)

## ---- ipm postprocess 2 --------
# combine survival data
temp.df<- data.frame(Draws=O.surv[,1], Cat="Hacked", State="First-year")
temp.df1<- data.frame(Draws=O.surv[,2], Cat="Sex", State="First-year")
temp.df2<- data.frame(Draws=0, Cat="Hacked", State="Breeder")
temp.df3<- data.frame(Draws=0, Cat="Sex", State="Breeder")
temp.df4<- data.frame(Draws=0, Cat="Hacked", State="Non-breeder")
temp.df5<- data.frame(Draws=0, Cat="Sex", State="Non-breeder")
df.surv2<- rbind(temp.df, temp.df1, temp.df2, temp.df3, temp.df4, temp.df5)
df.surv2$combined<- factor(paste(df.surv2$State, df.surv2$Cat))
df.surv2$combined <- factor(df.surv2$combined, levels=levels(df.surv2$combined)[c(3,4,5,6,1,2)])

# combine recruitment data
temp.df<- data.frame(Draws=0, Cat="Hacked", State="First-year")
temp.df1<- data.frame(Draws=0, Cat="Sex", State="First-year")
temp.df2<- data.frame(Draws=0, Cat="Hacked", State="Breeder")
temp.df3<- data.frame(Draws=0, Cat="Sex", State="Breeder")
temp.df4<- data.frame(Draws=A.trans[,1], Cat="Hacked", State="Non-breeder")
temp.df5<- data.frame(Draws=A.trans[,2], Cat="Sex", State="Non-breeder")
df.rec2<- rbind(temp.df, temp.df1, temp.df2, temp.df3, temp.df4, temp.df5)
df.rec2$combined<- factor(paste(df.rec2$State, df.rec2$Cat))
df.rec2$combined <- factor(df.rec2$combined, levels=levels(df.rec2$combined)[c(3,4,5,6,1,2)])

# combine resight data
temp.df2<- data.frame(Draws=0, Cat="Hacked", State="Breeder")
temp.df3<- data.frame(Draws=0, Cat="Sex", State="Breeder")
temp.df4<- data.frame(Draws=B.recap[,1], Cat="Effort", State="Breeder")
temp.df5<- data.frame(Draws=0, Cat="Hacked", State="Non-breeder")
temp.df6<- data.frame(Draws=0, Cat="Sex", State="Non-breeder")
temp.df7<- data.frame(Draws=A.recap[,2], Cat="Effort", State="Non-breeder")
df.recap2<- rbind(temp.df2, temp.df3, temp.df4, temp.df5, temp.df6, temp.df7)
df.recap2$combined<- factor(paste(df.recap2$State, df.recap2$Cat))
df.recap2$combined <- factor(df.recap2$combined, levels=c(levels(df.recap2$combined)[c(4,5,6,1,2,3)])) #"First-year Hacked", "First-year Sex", 
# fix level order for plots
ord <- c("First-year","Non-breeder","Breeder")
df.surv2$State <-  factor(df.surv2$State, levels=ord, labels=ord) 
df.rec2$State <-  factor(df.rec2$State, levels=ord, labels=ord) 
df.recap2$State <-  factor(df.recap2$State, levels=ord[-1], labels=ord[-1]) 
 
```


```{r survdiffs3, fig.width=10, fig.height=10, fig.cap= "Fig. S8. Violin plots of differences in survival, recruitment, and recapture estimates from IPM without immigration."}
data_summary <- function(x,...) {
  m <- median(x)
  ymin <- HDIofMCMC(x, credMass=0.95)[[1]]
  ymax <- HDIofMCMC(x, credMass=0.95)[[2]]
  return(c(y=m,ymin=ymin,ymax=ymax))
}
txt <- 30
lwd <- 1.5

ps <- ggplot(df.surv2, aes(x = combined, y = Draws, group=combined )) +
  scale_y_continuous(breaks=c(-0.5, 0, 0.5),  labels=c(-0.5, 0, 0.5)) +
  geom_hline(yintercept=0, linetype="solid", size=lwd) +
  geom_violin(aes(fill=State)) + scale_fill_manual(values=c("First-year"="#f7f7f7", "Non-breeder"="#cccccc", "Breeder"="#969696")) +
  stat_summary(fun.data=data_summary,  geom="pointrange", size=lwd) +
  theme_classic() + theme (text = element_text(size=txt)) +  
  ylab("Survival\ndifference") + xlab ("") + 
  scale_x_discrete( labels=c("Hacked", "Sex", "Hacked", "Sex","Hacked", "Sex" )) 
  
pt <- ggplot(df.rec2, aes(x = combined, y = Draws, group=combined )) +
  scale_y_continuous(breaks=c(-0.5, 0, 0.5),  labels=c(-0.5, 0, 0.5)) +
  geom_hline(yintercept=0, linetype="solid", size=lwd) +
  geom_violin(aes(fill=State)) +  scale_fill_manual(values=c("First-year"="#f7f7f7", "Non-breeder"="#cccccc", "Breeder"="#969696")) + 
  stat_summary(fun.data=data_summary,  geom="pointrange", size=lwd) +
  theme_classic() + theme (text = element_text(size=txt)) +
  ylab("Recruitment\ndifference") + xlab ("") + 
  scale_x_discrete( labels=c("Hacked", "Sex", "Hacked", "Sex","Hacked", "Sex" ))

pr <- ggplot(df.recap2, aes(x = combined, y = Draws, group=combined)) +
  scale_y_continuous(breaks=c(-0.5, 0, 0.5),  labels=c(-0.5, 0, 0.5)) +
  geom_hline(yintercept=0, linetype="solid", size=lwd) +
  geom_violin(aes(fill=State)) +  scale_fill_manual(values=c("First-year"="#f7f7f7",
    "Non-breeder"="#cccccc", "Breeder"="#969696")) +
  stat_summary(fun.data=data_summary,  geom="pointrange", size=lwd) +
  theme_classic() + theme (text = element_text(size=txt)) +
  ylab("Resight\ndifference") + xlab ("") +
  scale_x_discrete( labels=c("Effort", "Hacked", "Sex", "Effort", "Hacked", "Sex" ))

grid.arrange(ps + theme(legend.position=c(0.5,0.95), legend.direction="horizontal",legend.background = element_rect(fill = "transparent")), 
             pt + theme(legend.position="none"), 
             pr + theme(legend.position="none"), 
             nrow=3,
             layout_matrix = rbind(c(1, 1, 1, 1, 1, 1),
                                   c(2, 2, 2, 2, 2, 2),
                                   c(3, 3, 3, 3, 3, 3))) 
```

```{r ppipm2, eval=TRUE}
########################
# Plot mean estimates with 95% HDIs 
#######################
source("R\\HDIofMCMC.R")
df4<- df3<- df2 <- df1 <- data.frame(param=NA , md=NA, lhdi85=NA, uhdi85=NA, lhdi95=NA, uhdi95=NA)
# params with 1 estimate
for (i in 1:3){
ind <- c(17,18,21)[i]
df1[i,1] <- names(out$sims.list)[ind]
df1[i,2] <- median(out$sims.list[[ind]] )
df1[i,3:4] <- HDIofMCMC(out$sims.list[[ind]], credMass=0.85)
df1[i,5:6] <- HDIofMCMC(out$sims.list[[ind]])
}

# params with 2 estimates
ind <- 19
df2[1,1] <- paste(names(out$sims.list)[ind], "_1", sep="")
df2[1,2] <- median(out$sims.list[[ind]][,1] )
df2[1,3:4] <- HDIofMCMC(out$sims.list[[ind]][,1], credMass=0.85)
df2[1,5:6] <- HDIofMCMC(out$sims.list[[ind]][,1], credMass=0.95)
df2[2,1] <- paste(names(out$sims.list)[ind], "_2", sep="")
df2[2,2] <- median(out$sims.list[[ind]][,2] )
df2[2,3:4] <- HDIofMCMC(out$sims.list[[ind]][,2], credMass=0.85)
df2[2,5:6] <- HDIofMCMC(out$sims.list[[ind]][,2], credMass=0.95)
ind <- 23
df2[3,1] <- paste(names(out$sims.list)[ind], "_1", sep="")
df2[3,2] <- median(out$sims.list[[ind]][,1] )
df2[3,3:4] <- HDIofMCMC(out$sims.list[[ind]][,1], credMass=0.85)
df2[3,5:6] <- HDIofMCMC(out$sims.list[[ind]][,1], credMass=0.95)
df2[4,1] <- paste(names(out$sims.list)[ind], "_2", sep="")
df2[4,2] <- median(out$sims.list[[ind]][,2] )
df2[4,3:4] <- HDIofMCMC(out$sims.list[[ind]][,2], credMass=0.85)
df2[4,5:6] <- HDIofMCMC(out$sims.list[[ind]][,2], credMass=0.95)

ind <- c(16, 20, 22)[1]
df4[1,1] <- paste(names(out$sims.list)[ind], "_1_1", sep="")
df4[1,2] <- median(out$sims.list[[ind]][,1,1] )
df4[1,3:4] <- HDIofMCMC(out$sims.list[[ind]][,1,1], credMass=0.85)
df4[1,5:6] <- HDIofMCMC(out$sims.list[[ind]][,1,1], credMass=0.95)
df4[2,1] <- paste(names(out$sims.list)[ind], "_2_1", sep="")
df4[2,2] <- median(out$sims.list[[ind]][,2,1] )
df4[2,3:4] <- HDIofMCMC(out$sims.list[[ind]][,2,1], credMass=0.85)
df4[2,5:6] <- HDIofMCMC(out$sims.list[[ind]][,2,1], credMass=0.95)
df4[3,1] <- paste(names(out$sims.list)[ind], "_1_2", sep="")
df4[3,2] <- median(out$sims.list[[ind]][,1,2] )
df4[3,3:4] <- HDIofMCMC(out$sims.list[[ind]][,1,2], credMass=0.85)
df4[3,5:6] <- HDIofMCMC(out$sims.list[[ind]][,1,2], credMass=0.95)
df4[4,1] <- paste(names(out$sims.list)[ind], "_2_2", sep="")
df4[4,2] <- median(out$sims.list[[ind]][,2,2] )
df4[4,3:4] <- HDIofMCMC(out$sims.list[[ind]][,2,2], credMass=0.85)
df4[4,5:6] <- HDIofMCMC(out$sims.list[[ind]][,2,2], credMass=0.95)
ind <- c(16, 20, 22)[2]
df4[5,1] <- paste(names(out$sims.list)[ind], "_1_1", sep="")
df4[5,2] <- median(out$sims.list[[ind]][,1,1] )
df4[5,3:4] <- HDIofMCMC(out$sims.list[[ind]][,1,1], credMass=0.85)
df4[5,5:6] <- HDIofMCMC(out$sims.list[[ind]][,1,1], credMass=0.95)
df4[6,1] <- paste(names(out$sims.list)[ind], "_2_1", sep="")
df4[6,2] <- median(out$sims.list[[ind]][,2,1] )
df4[6,3:4] <- HDIofMCMC(out$sims.list[[ind]][,2,1], credMass=0.85)
df4[6,5:6] <- HDIofMCMC(out$sims.list[[ind]][,2,1], credMass=0.95)
df4[7,1] <- paste(names(out$sims.list)[ind], "_1_2", sep="")
df4[7,2] <- median(out$sims.list[[ind]][,1,2] )
df4[7,3:4] <- HDIofMCMC(out$sims.list[[ind]][,1,2], credMass=0.85)
df4[7,5:6] <- HDIofMCMC(out$sims.list[[ind]][,1,2], credMass=0.95)
df4[8,1] <- paste(names(out$sims.list)[ind], "_2_2", sep="")
df4[8,2] <- median(out$sims.list[[ind]][,2,2] )
df4[8,3:4] <- HDIofMCMC(out$sims.list[[ind]][,2,2], credMass=0.85)
df4[8,5:6] <- HDIofMCMC(out$sims.list[[ind]][,2,2], credMass=0.95)
ind <- c(16, 20, 22)[3]
df4[9,1] <- paste(names(out$sims.list)[ind], "_1_1", sep="")
df4[9,2] <- median(out$sims.list[[ind]][,1,1] )
df4[9,3:4] <- HDIofMCMC(out$sims.list[[ind]][,1,1], credMass=0.85)
df4[9,5:6] <- HDIofMCMC(out$sims.list[[ind]][,1,1], credMass=0.95)
df4[10,1] <- paste(names(out$sims.list)[ind], "_2_1", sep="")
df4[10,2] <- median(out$sims.list[[ind]][,2,1] )
df4[10,3:4] <- HDIofMCMC(out$sims.list[[ind]][,2,1], credMass=0.85)
df4[10,5:6] <- HDIofMCMC(out$sims.list[[ind]][,2,1], credMass=0.95)
df4[11,1] <- paste(names(out$sims.list)[ind], "_1_2", sep="")
df4[11,2] <- median(out$sims.list[[ind]][,1,2] )
df4[11,3:4] <- HDIofMCMC(out$sims.list[[ind]][,1,2], credMass=0.85)
df4[11,5:6] <- HDIofMCMC(out$sims.list[[ind]][,1,2], credMass=0.95)
df4[12,1] <- paste(names(out$sims.list)[ind], "_2_2", sep="")
df4[12,2] <- median(out$sims.list[[ind]][,2,2] )
df4[12,3:4] <- HDIofMCMC(out$sims.list[[ind]][,2,2], credMass=0.85)
df4[12,5:6] <- HDIofMCMC(out$sims.list[[ind]][,2,2], credMass=0.95)

df<- rbind(df1,df2,df4) 
df<- df[c(8,9,10,11,1,2,4,5,12,13,14,15,3,16,17,18,19,6,7),]

df$parameter <- c(rep("Survival",6), rep("Recruitment",7), rep("Resight",6))

df$lifestage <- c("First-year", "First-year","First-year", 
"First-year", "Nonbreeder", "Breeder", 
  "First-year to breeder", "First-year to breeder", "Nonbreeder to breeder" , "Nonbreeder to breeder" , "Nonbreeder to breeder" , "Nonbreeder to breeder" , "Breeder to nonbreeder",
  "Nonbreeder", "Nonbreeder", "Nonbreeder", "Nonbreeder","Breeder", "Breeder")

df$she <- c("female, wild","male, wild",
            "female, hacked","male, hacked",
            "","",
            "female", "male",
            "female, wild","male, wild",
            "female, hacked","male, hacked",
            "",
            "female, wild","male, wild",
            "female, hacked","male, hacked",
            "female", "male")
df <- df[,c(7,8,9,2,5,6,3,4)]
  
df[,c(4:8)] <- format(round(df[,c(4:8)], digits=2), nsmall=2)
# print estimates for survival, recruitment, and resight probabilities
df

```

# 3. Goodness-of-fit tests for the IPM
```{r GOFprod, fig.width=6, fig.height=4, fig.cap= "Fig. S9. Goodness-of-fit tests for IPM.", fig.show="hold", out.width="100%"}
load(".\\outputs\\ipm-e.Rdata")
par(mfrow=c(2,3), oma=c(0,0,5,0))
plot(out$sims.list$dd.obs, out$sims.list$dd.rep,
     main="Poisson regression model\nfor Productivity",
     ylab="Discrepancy replicate values",
     xlab="Discrepancy observed values",
     xlim=c(0,40), ylim=c(0,40),
     pch=16, cex=0.1, col="gray10")
curve(1*x, from=0, to=40, add=T, lty=2, lwd=2, col="blue")
bp <- round(mean(out$sims.list$dd.rep > out$sims.list$dd.obs),2)
loc <- ifelse(bp < 0.5, "topleft", "bottomright")
legend(loc, legend=bquote(p[B]==.(bp)), bty="n")

hist(out$sims.list$tvm.rep, nclass=50,
     xlab="variance/mean ", main=NA, axes=FALSE)
abline(v=out$mean$tvm.obs, col="red")
axis(1); axis(2)
```

```{r GOFb, fig.width=6, fig.height=4, fig.cap= "Fig. S10. Goodness-of-fit tests for breeder counts in the IPM."}
plot(jitter(out$sims.list$dmape.obs[,1], amount=300), 
     jitter(out$sims.list$dmape.rep[,1], amount=300),
     main="State-space model\n for Breeder counts",
     ylab="Discrepancy replicate values",
     xlab="Discrepancy observed values", 
     xlim=c(0,8000), ylim=c(0,8000), 
     pch=16, cex=0.1, col="gray10")
curve(1*x, from=0, to=8000, add=T, lty=2, lwd=2, col="blue")
bp <- round(mean(out$sims.list$dmape.rep[,1] > out$sims.list$dmape.obs[,1]),2)
loc <- ifelse(bp < 0.5, "topleft", "bottomright")
legend(loc, legend=bquote(p[B]==.(bp)), bty="n")
```

```{r GOFnb, fig.width=6, fig.height=4, fig.cap= "Fig. S11. Goodness-of-fit tests for non-breeder counts in the IPM."}
plot(jitter(out$sims.list$dmape.obs[,2], amount=300), 
     jitter(out$sims.list$dmape.rep[,2], amount=300),
     main="State-space model\n for non-breeder counts",
     ylab="Discrepancy replicate values",
     xlab="Discrepancy observed values", 
     xlim=c(0,15000), ylim=c(0,15000), 
     pch=16, cex=0.1, col="gray10")
curve(1*x, from=0, to=30000, add=T, lty=2, lwd=2, col="blue")
bp <- round(mean(out$sims.list$dmape.rep[,2] > out$sims.list$dmape.obs[,2]),2)
loc <- ifelse(bp < 0.5, "topleft", "bottomright")
legend(loc, legend=bquote(p[B]==.(bp)), bty="n")
```

```{r GOFfy, fig.width=6, fig.height=4, fig.cap= "Fig. S12. Goodness-of-fit tests for first-year counts in the IPM."}
plot(jitter(out$sims.list$dmape.obs[,3], amount=200), 
     jitter(out$sims.list$dmape.rep[,3], amount=200),
     main="State-space model\n for first-year counts",
     ylab="Discrepancy replicate values",
     xlab="Discrepancy observed values", 
     xlim=c(0,12000), ylim=c(0,12000),
     pch=16, cex=0.1, col="gray10")
curve(1*x, from=0, to=15000, add=T, lty=2, lwd=2, col="blue")
bp <- round(mean(out$sims.list$dmape.rep[,3] > out$sims.list$dmape.obs[,3]),2)
loc <- ifelse(bp < 0.5, "topleft", "bottomright")
legend(loc, legend=bquote(p[B]==.(bp)), bty="n")
```

# 4. Literature cited  

Abadi, F., O. Gimenez, B. Ullrich, R. Arlettaz, and M. Schaub. 2010. Estimation of immigration rate using integrated population models. Journal of Applied Ecology 47:393–400.

Gimenez, O., V. Rossi, R. Choquet, C. Dehais, B. Doris, H. Varella, J.-P. Vila, and R. Pradel. 2007. State-space modelling of data on marked individuals. Ecological Modelling 206:431–438.

Kéry, M., and M. Schaub. 2012. Bayesian Population Analysis Using WinBUGS: A hierarchical perspective. First Edit. Elselvier Inc., Oxford, UK.

Krushke, J. K. 2011. Doing Bayesian Data Analysis: A Tutorial with R and BUGS. Elsevier Inc., Burlington, Massachusetts, USA.

Paquet, M., J. Knape, D. Arlt, P. Forslund, T. Pärt, Ø. Flagstad, C. G. Jones, M. A. C. Nicoll, K. Norris, J. M. Pemberton, H. Sand, L. Svensson, V. Tatayah, P. Wabakken, C. Wikenros, M. Åkesson, and M. Low. 2021. Integrated population models poorly estimate the demographic contribution of immigration. Methods in Ecology and Evolution 12:1899–1910.

Royle, J. A. 2008. Modeling Individual Effects in the Cormack–Jolly–Seber Model: A State–Space Formulation. Biometrics 64:364–370.

Schaub, M., and D. Fletcher. 2015. Estimating immigration using a Bayesian integrated population model: choice of parametrization and priors. Environmental and Ecological Statistics 22:535–549.